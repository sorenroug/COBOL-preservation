<?xml version="1.0"?>
<chapter xmlns="http://docbook.org/ns/docbook">
  <title>INDEXED INPUT AND OUTPUT</title>
  <section>
    <title>INTRODUCTION TO THE INDEXED I-O MODULE</title>
    <indexterm>
      <primary>Indexed I-O Module</primary>
    </indexterm>
    <para>
The Indexed I-O module provides a capability to access records of a
mass storage file in either a random or sequential manner.
Each record in an indexed file is uniquely identified by the value of one key within that record.
</para>
    <section>
      <title>LANGUAGE CONCEPTS</title>
      <indexterm>
        <primary>Language Concepts</primary>
      </indexterm>
      <section>
        <title>Organization</title>
      <indexterm>
        <primary>Organisation, Indexed</primary>
      </indexterm>
        <para>
A file whose organization is indexed is a mass storage file in which
data records may be accessed by the value of a key. A record description
includes a key data item, which is associated with an index. The index
provides a logical path to the data records according to the contents of a
data item within each record which is the record key.
</para>
        <para>
The data item named in the RECORD KEY clause of the file control entry
for a file is the record key for that file. For purposes of inserting,
updating and deleting records in a file, each record is identified solely by
the value of its record key. This value must, therefore, be unique and must
not be changed when updating the record. <phrase role="extension">The key length must not exceed 32 bytes.</phrase>
See the <citetitle pubwork="book">CIS COBOL Operating Guide</citetitle> for the maximum records in a file.
</para>
      </section>
      <section>
        <title>Access Modes</title>
        <indexterm>
          <primary>Access Mode</primary>
        </indexterm>
        <indexterm>
          <primary>Mode, Access</primary>
        </indexterm>
        <para>
In the sequential access mode, the sequence in which records are
accessed is the ascending order of the record key values.
</para>
        <para>
     In the random access mode, the sequence in which records are accessed
is controlled by the programmer. The desired record is accessed by placing
the value of its record key in the record key data item.
</para>
        <para>
     In the dynamic access mode, the programmer may change at will from
sequential access to random access using appropriate forms of input-output
statements.
</para>
      </section>
      <section>
        <title>Current Record Pointer</title>
        <indexterm>
          <primary>Current Record Pointer</primary>
        </indexterm>
        <indexterm>
          <primary>Record Pointer, Current</primary>
        </indexterm>
        <para>
     The current record pointer is a conceptual entity used in this document
to facilitate specification of the next record to be accessed within a given
file. The concept of the current record pointer has no meaning for a file
opened only in the output mode. The setting of the current record pointer
is affected only by the OPEN, START and READ statements.
</para>
      </section>
      <section xml:id="sec7.i.o">
        <title>I-O Status</title>
        <indexterm>
          <primary>Input-Output Status</primary>
        </indexterm>
        <indexterm>
          <primary>Status, Input-Output</primary>
        </indexterm>
        <para>
If the FILE STATUS clause is specified in a file control entry, a value
is placed into the specified two-character data item during the execution of
an OPEN, CLOSE, READ, WRITE, REWRITE, DELETE or START statement and before
any applicable USE procedure is executed, to indicate to the COBOL program
the status or that input-output operation.
</para>
        <section>
          <title>Status Key 1</title>
          <indexterm>
            <primary>Status Keys</primary>
          </indexterm>
          <indexterm>
            <primary>Keys, Status</primary>
          </indexterm>
          <para>
The leftmost character position of the FILE STATUS data item is known
as status key 1 and is set to indicate one of the following conditions upon
completion of the input-output operation.
</para>
          <itemizedlist mark="none" spacing="compact">
            <listitem>
              <para>'0' - Successful Completion</para>
            </listitem>
            <listitem>
              <para>'1' - At End</para>
            </listitem>
            <listitem>
              <para>'2' - Invalid Key</para>
            </listitem>
            <listitem>
              <para>'3' - Permanent Error</para>
            </listitem>
            <listitem>
              <para>'9' - Operating System Error Message</para>
            </listitem>
          </itemizedlist>
          <para>
The meaning of the above indications are as follows:
</para>
          <variablelist>
            <varlistentry>
              <term>0</term>
              <listitem>
                <para>Successful Completion. The input-output statement was
               successfully executed.
               </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>1</term>
              <listitem>
                <para>At End. The Format 1 READ statement was unsuccessfully
               executed as a result of an attempt to read a record when no
               next logical record exists in the file.
               </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>2</term>
              <listitem>
                <para>Invalid Key. The input-output statement was unsuccessfully
              executed as a result of one of the following:
          </para>
                <itemizedlist spacing="compact">
                  <listitem>
                    <para>
Sequence Error
               </para>
                  </listitem>
                  <listitem>
                    <para>
Duplicate Key
               </para>
                  </listitem>
                  <listitem>
                    <para>
No Record Found
               </para>
                  </listitem>
                  <listitem>
                    <para>
Boundary Violation
               </para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>3</term>
              <listitem>
                <para>Permanent Error. The input-output statement was unsuccessfully
              executed as the result of an input-output error, such as data
              check, parity error or transmission error.
               </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>9</term>
              <listitem>
                <para>Operating System Error Message. The input-output statement
               was unsuccessfully executed as a result of a condition that
               is specified by the Operating System Error Message. This
               value is used only to indicate a condition not indicated by
               other defined values of status key 1, or by specified
               combinations of the values of status key 1 and status key 2.
               </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>Status Key 2</title>
          <para>
The rightmost character position of the FILE STATUS data item is known
   as status key 2 and is used to further describe the results of the
   input-output operation. This character will contain a value as follows:
   </para>
          <para>
         If no further information is available concerning the input-output
         operation, then status key 2 contains a value of '0'.
</para>
          <para>
When status key 1 contains a value of '2' indicating an INVALID KEY
condition, status key 2 contains values to designate the cause of that
condition as follows:
</para>
          <variablelist termlength="3" spacing="compact">
            <varlistentry>
              <term>1 -</term>
              <listitem>
                <para>
Indicates a sequence error for a sequentially accessed
indexed file. The ascending sequence requirements of
successive record key values have been violated
(see The WRITE Statement later in this Chapter), or the record key
value has been changed by the COBOL program between the
successful execution of a READ statement and the execution of
the next REWRITE statement for that file.
</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>2 -</term>
              <listitem>
                <para>Indicates a duplicate key value. An attempt has been
                     made to write a record that would create a duplicate key
                     in an indexed file.
</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>3 -</term>
              <listitem>
                <para>Indicates no record found. An attempt has been made to
                     access a record, identified by a key, and that record
                     does not exist in the file,
</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>4 -</term>
              <listitem>
                <para>Indicates a boundary violation. An attempt has been
                     made to write beyond the externally-defined boundaries
                     of a indexed file. This is normally treated as a fatal
                     error by Operating Systems.
</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>
When status key 1 contains a value of '9' the value of status key 2 is
the operating system error message number (for those operating systems
which designate errors numerically). The <citetitle pubwork="book">CIS COBOL Operating Guide</citetitle>
specific to your operating system contains details of the status-key-2
representation.
</para>
          <para>
     Note that it is not possible to extract this number directly.
</para>
        </section>
        <section>
          <title>Valid Combinations of Status Keys 1 and 2</title>
          <para>
     The valid permissible combinations of the value of status key 1 and
status key 2 are shown in the following table. An 'X' at an intersection
indicates a valid permissible combination.
</para>
          <informaltable frame="all" colsep="1" rowsep="1">
            <tgroup cols="6">
              <colspec colwidth="1.2in" align="left" colname="c1"/>
              <colspec colwidth=".7in" align="left" colname="c2"/>
              <colspec colwidth=".7in" align="left" colname="c3"/>
              <colspec colwidth=".7in" align="left" colname="c4"/>
              <colspec colwidth=".7in" align="left" colname="c5"/>
              <colspec colwidth=".7in" align="left" colname="c6"/>
              <tbody>
                <row>
                  <entry morerows="1">Status Key 1</entry>
                  <entry namest="c2" nameend="c6">Status Key 2</entry>
                </row>
                <row>
                  <entry>No Further Information (0)</entry>
                  <entry>Sequence Error (1)</entry>
                  <entry>Duplicate Key (2)</entry>
                  <entry>No Record Found (3)</entry>
                  <entry>Boundary Violation (4)</entry>
                </row>
                <row>
                  <entry>Successful Completion (0)</entry>
                  <entry>X</entry>
                  <entry/>
                  <entry>X</entry>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry>At End (1)</entry>
                  <entry>X</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry>Invalid Key (2)</entry>
                  <entry/>
                  <entry>X</entry>
                  <entry>X</entry>
                  <entry>X</entry>
                  <entry>X</entry>
                </row>
                <row>
                  <entry>Permanent Error (3)</entry>
                  <entry>X</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry>Implementor Defined (9)</entry>
                  <entry namest="c2" nameend="c6">Operating System Error Message Number</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section xml:id="sec7.inv.key">
          <title>The INVALID KEY Condition</title>
          <para>
The INVALID KEY condition can occur as a result of the execution of a
START, READ, WRITE, REWRITE or DELETE statement. For details of the causes
of the condition see THE START STATEMENT, THE READ STATEMENT,
THE WRITE STATEMENT, and THE DELETE STATEMENT later in this Chapter.
        </para>
          <para>
             When the INVALID KEY condition is recognised, the Operating System
        takes these actions in the following order:
        </para>
          <orderedlist>
            <listitem>
              <para>
A value is placed into the FILE STATUS data item, if specified for this
file, to indicate an INVALID KEY condition. (See <xref linkend="sec7.i.o"/>).
        </para>
            </listitem>
            <listitem>
              <para>
If the INVALID KEY phrase is specified in the statement causing the
condition, control is transferred to the INVALID KEY imperative
statement. Any USE procedure specified for this file is not executed.
When the INVALID KEY condition occurs, execution of the input-output
statement which recognised the condition is unsuccessful and the file
is not affected.
</para>
            </listitem>
          </orderedlist>
        </section>
        <section>
          <title>The AT END Condition</title>
          <indexterm>
            <primary>AT END Condition</primary>
          </indexterm>
          <indexterm>
            <primary>Conditions, AT END</primary>
          </indexterm>
          <para>
The AT END condition can occur as a result of the execution of a READ
statement. For details of the causes of the condition,
see THE READ STATEMENT later in this Chapter.
</para>
        </section>
      </section>
    </section>
  </section>
  <section>
    <title>ENVIRONMENT DIVISION IN THE INDEXED I-O MODULE</title>
    <indexterm>
      <primary>Environment Division in Indexed I-O</primary>
    </indexterm>
    <indexterm>
      <primary>Indexed I-O Module, Environment Division</primary>
    </indexterm>
    <section>
      <title>INPUT-OUTPUT SECTION</title>
      <indexterm>
        <primary>Input-Output Section</primary>
      </indexterm>
      <indexterm>
        <primary>Section, Input-Output</primary>
      </indexterm>
      <section>
        <title>The File Control Paragraph</title>
        <indexterm>
          <primary>FILE-CONTROL Paragraph</primary>
        </indexterm>
        <indexterm>
          <primary>Paragraph, FILE-CONTROL</primary>
        </indexterm>
        <section>
          <title>Function</title>
          <para>
The FILE-CONTROL paragraph names each file and allows specification of
other file-related information. (See also appendix F in the
<citetitle pubwork="book">CIS COBOL Operating Guide</citetitle>).
</para>
        </section>
        <section>
          <title>General Format</title>
          <cmdsynopsis>
            <command>FILE-CONTROL</command>
            <arg choice="req" rep="repeat">file-control-entry</arg>
          </cmdsynopsis>
        </section>
      </section>
      <section>
        <title>The File Control Entry</title>
        <indexterm>
          <primary>FILE-CONTROL Entry</primary>
        </indexterm>
        <indexterm>
          <primary>Entry, FILE-CONTROL</primary>
        </indexterm>
        <indexterm>
          <primary>SELECT Clause</primary>
        </indexterm>
        <indexterm>
          <primary>Clause, SELECT</primary>
        </indexterm>
        <section>
          <title>Function</title>
          <para>
The file control entry names a file and may specify other file-related information.
</para>
        </section>
        <section>
          <title>General Format</title>
        <indexterm>
          <primary>FILE STATUS Clause</primary>
        </indexterm>
        <indexterm>
          <primary>Clause, FILE STATUS</primary>
        </indexterm>
          <cmdsynopsis>
            <command>SELECT</command>
            <arg>file-name</arg>
            <sbr/>
            <arg>ASSIGN TO</arg>
            <group choice="req">
              <arg>external-file-name-literal</arg>
              <arg>file-identifier</arg>
            </group>
            <arg choice="opt">
              <arg>,</arg>
              <group choice="req">
                <arg>external-file-name-literal</arg>
                <arg>file-identifier</arg>
              </group>
            </arg>
            <sbr/>
            <arg>; ORGANIZATION IS INDEXED</arg>
            <sbr/>
            <arg choice="opt">
              <arg>; ACCESS MODE IS</arg>
              <group choice="req">
                <arg>SEQUENTIAL</arg>
                <arg>RANDOM</arg>
                <arg>DYNAMIC</arg>
              </group>
            </arg>
            <sbr/>
            <arg>; RECORD KEY IS data-name-1</arg>
            <sbr/>
            <arg choice="opt">; FILE STATUS IS data-name-3</arg>
          </cmdsynopsis>
        </section>
        <section>
          <title>Syntax Rules</title>
          <orderedlist>
            <listitem>
              <para>The SELECT clause must be specified first in the file control entry.
  The clauses which follow the SELECT clause may appear in any order.</para>
            </listitem>
            <listitem>
              <para>Each file described 1:1 the Data Division must be named once and only
   once as file-name in the FILE-CONTROL paragraph. Each file specified
   in the file control entry must have a file description entry in the
   Data Division.</para>
            </listitem>
            <listitem>
              <para>If the ACCESS MODE clause is not specified, the ACCESS MODE IS SEQUENTIAL clause is implied.</para>
            </listitem>
            <listitem>
              <para>Data-name-3 must be defined in the Data Division as a two-character
   data item of the category alphanumeric and must not be defined in the File Section.</para>
            </listitem>
            <listitem>
              <para>The data items referenced by data-name-1 must each be defined as a data
item of the category alphanumeric within a record description entry
associated with that file-name.</para>
            </listitem>
          </orderedlist>
        </section>
        <section>
          <title>General Rules</title>
          <indexterm>
            <primary>ASSIGN Clause</primary>
          </indexterm>
          <indexterm>
            <primary>Clause, ASSIGN</primary>
          </indexterm>
          <orderedlist>
            <listitem>
              <para>
The ASSIGN clause specifies the association of the file referenced by
file-name to a storage medium. See Appendix F in the <citetitle pubwork="book">CIS COBOL Operating Guide</citetitle>.
<phrase role="extension">The first assignment takes effect. Subsequent
assignments within any one ASSIGN clause are for documentation purposes only.</phrase>
</para>
            </listitem>
            <listitem>
              <indexterm>
                <primary>ORGANIZATION IS INDEXED</primary>
              </indexterm>
              <indexterm>
                <primary>Clause, ORGANIZATION</primary>
              </indexterm>
              <para>
The ORGANIZATION clause specifies the logical structure of a file.
The File organization is established at the time a file is created and
cannot subsequently be changed.
</para>
            </listitem>
            <listitem>
              <para>
When the access mode is sequential, records in the file are accessed in
the sequence dictated by the file organization. For indexed files this
sequence is the order of ascending record key values.
</para>
            </listitem>
            <listitem>
              <para>
When the FILE STATUS clause is specified, a value will be moved by the
operating system into the data item specified by data-name-3 after the
execution of every statement that references that file either
explicitly or implicitly. This value indicates the status of execution
of the statement. (See <xref linkend="sec7.i.o"/> in this Chapter).
</para>
            </listitem>
            <listitem>
              <para>
If the access mode is random, the value of the record key data item
indicates the record to be accessed.
</para>
            </listitem>
            <listitem>
              <para>
When the access mode is dynamic, records in the file may be accessed
sequentially and/or randomly. (See general rules 4 and 6).
</para>
            </listitem>
            <listitem>
              <indexterm>
                <primary>RECORD KEY Clause</primary>
              </indexterm>
              <indexterm>
                <primary>Clause, RECORD KEY</primary>
              </indexterm>
              <para>
The RECORD KEY clause specifies the record key for a file. The values
of a record key must be unique among records of the file. This record
key provides an access path to records in an indexed file.
</para>
            </listitem>
            <listitem>
              <para>
The data description of data-name-1 as well as relative locations
within a record must be the same as that used when the file was created.
</para>
            </listitem>
          </orderedlist>
        </section>
      </section>
      <section>
        <title>The I-O Control Paragraph</title>
        <indexterm>
          <primary>I-O Control Paragraph</primary>
        </indexterm>
        <indexterm>
          <primary>Paragraph, I-O CONTROL</primary>
        </indexterm>
        <section>
          <title>Function</title>
          <para>
The I-O-CONTROL paragraph specifies the points at which rerun is to be
established and the memory area which is to be shared by different files.
</para>
        </section>
        <section>
          <title>General Format</title>
          <cmdsynopsis>
            <command>I-O-CONTROL.</command>
            <arg choice="opt" rep="repeat">
              <arg>; RERUN</arg>
              <arg choice="opt">
                <arg>ON</arg>
                <group choice="req">
                  <arg>file-name-1</arg>
                  <arg>implementor-name</arg>
                </group>
              </arg>
              <arg>EVERY</arg>
              <group choice="req">
                <arg>integer-1 RECORDS OF file-name-2</arg>
                <arg>integer-2 CLOCK-UNITS</arg>
                <arg>condition-name</arg>
              </group>
            </arg>
            <sbr/>
            <arg choice="opt" rep="repeat">
              <arg>; SAME AREA FOR file-name-3</arg>
              <arg choice="opt" rep="repeat">, file-name-4</arg>
            </arg>
            <arg>.</arg>
          </cmdsynopsis>
        </section>
        <section>
          <title>Syntax Rules</title>
          <orderedlist>
            <listitem>
              <para>
The I-O-CONTROL paragraph is optional.
  <phrase role="extension">The whole clause is for documentation purposes only when present.</phrase>
</para>
            </listitem>
            <listitem>
              <para>
File-name-1 must be a sequentially organized file.
</para>
            </listitem>
            <listitem>
              <para>
When either the integer-1 RECORDS clause or the integer-2 CLOCK-UNITS
clause is specified, implementor-name must be given in the RERUN clause.
</para>
            </listitem>
            <listitem>
              <para>
When multiple integer-1 RECORDS clauses are specified, no two of them
may specify the same file-name-2.
</para>
            </listitem>
            <listitem>
              <para>
Only one RERUN clause containing the CLOCK-UNITS clause may be specified.
</para>
            </listitem>
            <listitem>
              <para>
More than one SAME clause (SAME AREA) may be included in a program but
a file-name must not appear in more than one SAME AREA clause.
</para>
            </listitem>
            <listitem>
              <para>
The files referenced in the SAME AREA clause need not all have the same
organization or access.
</para>
            </listitem>
          </orderedlist>
        </section>
        <section>
          <title>General Rules</title>
          <orderedlist>
            <listitem>
              <para>
                <phrase role="extension">The RERUN clause is treated as for documentation purposes only.</phrase>
              </para>
            </listitem>
            <listitem>
              <para>
                <phrase role="extension">The SAME AREA clause is treated as for documentation purposes only.</phrase>
              </para>
            </listitem>
          </orderedlist>
        </section>
      </section>
    </section>
  </section>
  <section>
    <title>DATA DIVISION IN THE INDEXED I-O MODULE</title>
    <indexterm>
      <primary>Data Division in Indexed I-O</primary>
    </indexterm>
    <indexterm>
      <primary>Indexed I-O Module, Data Division</primary>
    </indexterm>
    <section>
      <title>FILE SECTION</title>
      <indexterm>
        <primary>FILE Section</primary>
      </indexterm>
      <indexterm>
        <primary>Section, FILE</primary>
      </indexterm>
      <para>
In a COBOL program the file description entry (FD) represents the
highest level of organisation in the File Section. The File Section header
is followed by a file description entry consisting of a level indicator
(FD), a file-name and a series of independent clauses. The FD clauses
specify the size of the logical and physical records, the presence or
absence of label records, the value of implementor-defined label items, and
the names of the data records which comprise the file. The entry itself is
terminated by a period.
</para>
    </section>
    <section>
      <title>RECORD DESCRIPTION STRUCTURE</title>
        <indexterm>
          <primary>Record Description Structure</primary>
        </indexterm>
        <indexterm>
          <primary>Structure, Record Description</primary>
        </indexterm>
      <para>
A record description consists of a set of data description entries
which describe the characteristics of a particular record. Each data
description entry consists of a level-number followed by a data-name if
required, followed by a series of independent clauses as required. A record
description has a hierarchical structure and therefore the clauses used with
an entry may vary considerably, depending upon whether or not it is followed
by subordinate entries. The structure of a record description is defined in
CONCEPTS OF LEVELS in Chapter 2 while the elements allowed in a record
description are shown in <xref linkend="c03.skeleton"/> in Chapter 3.
</para>
    </section>
    <section>
      <title>THE FILE DESCRIPTION - COMPLETE ENTRY SKELETON</title>
        <indexterm>
          <primary>File Description Entry</primary>
        </indexterm>
      <section>
        <title>Function</title>
        <para>
The file description furnishes information concerning the physical
structure, identification, and record names pertaining to a given file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <command>FD</command>
          <arg>file-name</arg>
          <arg choice="opt">
            <arg>; BLOCK CONTAINS integer-2</arg>
            <group choice="req">
              <arg>RECORDS</arg>
              <arg>CHARACTERS</arg>
            </group>
          </arg>
          <sbr/>
          <arg choice="opt">
            <arg>; RECORD CONTAINS</arg>
            <arg choice="opt">integer-3 TO</arg>
            <arg>integer-4 CHARACTERS</arg>
          </arg>
          <sbr/>
          <arg choice="ansi">
            <arg>; LABEL</arg>
            <group choice="req">
              <arg>RECORD IS</arg>
              <arg>RECORDS ARE</arg>
            </group>
            <group choice="req">
              <arg>STANDARD</arg>
              <arg>OMITTED</arg>
            </group>
          </arg>
          <sbr/>
          <arg>
            <arg>; VALUE OF data-name-1 IS literal-1</arg>
            <arg choice="opt" rep="repeat">, data-name-2 IS literal-2</arg>
          </arg>
          <arg choice="opt">
            <arg>; DATA</arg>
            <group choice="req">
              <arg>RECORD IS</arg>
              <arg>RECORDS ARE</arg>
            </group>
            <arg>data-name-3</arg>
            <arg choice="opt" rep="repeat">, data-name-4</arg>
            <arg>.</arg>
          </arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
The level indicator FD identifies the beginning of a file description
and must precede the file-name.
</para>
          </listitem>
          <listitem>
            <para>
The clauses which follow the name of the file are optional in many
cases, and their order of appearance is immaterial. <phrase role="extension">All clauses are
optional when the ANSI switch is unset.</phrase>
</para>
          </listitem>
          <listitem>
            <para>
One or more record description entries must follow the file description entry.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE BLOCK CONTAINS CLAUSE</title>
      <indexterm>
        <primary>BLOCK CONTAINS Clause</primary>
      </indexterm>
      <indexterm>
        <primary>Clause, BLOCK CONTAINS</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The BLOCK CONTAINS clause specifies the size of a physical record.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <command>BLOCK CONTAINS</command>
          <arg>integer-2</arg>
          <group choice="req">
            <arg>RECORDS</arg>
            <arg>CHARACTERS</arg>
          </group>
        </cmdsynopsis>
      </section>
      <section>
        <title>General Rule</title>
        <para>
          <phrase role="extension">The clause is required for documentation purposes only.</phrase>
        </para>
      </section>
    </section>
    <section>
      <title>THE DATA RECORDS CLAUSE</title>
      <indexterm>
        <primary>DATA RECORDS Clause</primary>
      </indexterm>
      <indexterm>
        <primary>Clause, DATA RECORDS</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The DATA RECORDS clause serves only as documentation for the names of
data records with their associated file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>DATA</arg>
          <group choice="req">
            <arg>RECORD IS</arg>
            <arg>RECORDS ARE</arg>
          </group>
          <arg>data-name-1</arg>
          <arg choice="opt">, data-name-2</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <para>
Data-name-1 and data-name-2 are the names of data records and must have
01 level-number record descriptions, with the same names, associated with them.
</para>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The presence of more than one data-name indicates that the file
contains more than one type of data record. These records may be of
differing sizes, different formats, etc. The order in which they are
listed is not significant.
</para>
          </listitem>
          <listitem>
            <para>
Conceptually, all data records within a file share the same area. This
is in no way altered by the presence of more than one type of data
record within the file.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE LABEL RECORDS CLAUSE</title>
      <indexterm>
        <primary>LABEL RECORDS Clause</primary>
      </indexterm>
      <indexterm>
        <primary>Clause, LABEL RECORDS</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The LABEL RECORDS clause specifies whether labels are present.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>LABEL</arg>
          <group choice="req">
            <arg>RECORD IS</arg>
            <arg>RECORDS ARE</arg>
          </group>
          <group choice="req">
            <arg>STANDARD</arg>
            <arg>OMITTED</arg>
          </group>
        </cmdsynopsis>
      </section>
      <section>
        <title>General Rule</title>
        <para>
          <phrase role="extension">This clause is used for documentation purposes only.</phrase>
        </para>
      </section>
    </section>
    <section>
      <title>THE RECORD CONTAINS CLAUSE</title>
      <indexterm>
        <primary>RECORD CONTAINS Clause</primary>
      </indexterm>
      <indexterm>
        <primary>Clause, RECORD CONTAINS</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
          The RECORD CONTAINS clause specifies the size of data records.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>RECORD CONTAINS</arg>
          <arg choice="opt">integer-1 TO</arg>
          <arg>integer-2 CHARACTERS</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>General Rule</title>
        <para>
The size of each data record is completely defined within the record
description entry, therefore this clause is never required.
<phrase role="extension">The RECORD CONTAINS clause is specified for documentation purposes only.</phrase>
</para>
      </section>
    </section>
    <section>
      <title>THE VALUE OF CLAUSE</title>
      <indexterm>
        <primary>VALUE OF Clause</primary>
      </indexterm>
      <indexterm>
        <primary>Clause, VALUE OF</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The VALUE OF clause specialises the description of an item in the label
records associated with a file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>VALUE OF</arg>
          <arg>data-name-1 IS literal-1</arg>
          <arg choice="opt" rep="repeat">, data-name-2 IS literal-2</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
              <phrase role="extension">This clause is used for documentation purposes only.</phrase>
            </para>
          </listitem>
          <listitem>
            <para>
A figurative constant may be substituted in the format above wherever a literal is specified.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
  </section>
  <section>
    <title>PROCEDURE DIVISION IN THE INDEXED I-O MODULE</title>
    <indexterm>
      <primary>Procedure Division in Indexed I-O</primary>
    </indexterm>
    <indexterm>
      <primary>Indexed I-O Module, Procedure Division</primary>
    </indexterm>
    <section>
      <title>THE CLOSE STATEMENT</title>
      <indexterm>
        <primary>CLOSE Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, CLOSE</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
     The CLOSE statement terminates the processing of files.
     <phrase role="extension">The LOCK phrase is for documentation purposes only.</phrase>
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>CLOSE</arg>
          <arg>file-name-1</arg>
          <arg choice="opt">WITH LOCK</arg>
          <arg choice="opt" rep="repeat">, file-name-2 <arg choice="opt">WITH LOCK</arg></arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rule</title>
        <para>
The files referenced in the CLOSE statement need not all have the same
organization or access.
</para>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
A CLOSE statement may only be executed for a file in an open mode.
</para>
          </listitem>
          <listitem>
            <para>
The action taken if a file is in the open mode when a STOP RUN
statement is executed is to close the file. The action taken for a file
that has been opened in a called program and not closed in that program
prior to the execution of a CANCEL statement for that program is to close the file.
</para>
          </listitem>
          <listitem>
            <para>
If a CLOSE statement has been executed for a file, no other statement
can be executed that references that file, either explicitly or
implicitly, unless an intervening OPEN statement for that file is executed.
</para>
          </listitem>
          <listitem>
            <para>
Following the successful execution of a CLOSE statement, the record
area associated with file-name is no longer available. The unsuccessful
execution of such a CLOSE statement leaves the availability of the
record area undefined.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE DELETE STATEMENT</title>
      <indexterm>
        <primary>DELETE Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, DELETE</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The DELETE statement logically removes a record from a file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>DELETE file-name RECORD</arg>
          <arg choice="opt">;INVALID KEY imperative-statement</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
The INVALID KEY phase must not be specified for a DELETE statement
which references a file which is in sequential access mode.
</para>
          </listitem>
          <listitem>
            <para>
The INVALID KEY phrase must be specified for a DELETE statement which
references a file which is not in sequential access mode and for which
an applicable USE procedure is not specified.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The associated file must be open in I-O mode at the time of the
execution of this statement.
(See THE OPEN STATEMENT later in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
For files in the sequential access mode, the last input-output
statement executed for file-name prior to the execution of the DELETE
statement must have been a successfully executed READ statement. The
record that was accessed by that READ statement is logically removed from the file.
</para>
          </listitem>
          <listitem>
            <para>
For a file in random or dynamic access mode, the record identified by
the contents of the record key data item associated with file-name is
logically removed from the file. If the file does not contain the
record specified by the key, an INVALID KEY condition exists.
(See <xref linkend="sec7.inv.key"/> in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
After the successful execution of a DELETE statement, the identified
record has been logically removed from the file and can no longer be accessed.
</para>
          </listitem>
          <listitem>
            <para>
The execution of a DELETE statement does not affect the contents of the
record area associated with file-name.
</para>
          </listitem>
          <listitem>
            <para>
The current record pointer is not affected by the execution of a DELETE statement.
</para>
          </listitem>
          <listitem>
            <para>
The execution of the DELETE statement causes the value of the specified
FILE STATUS data item, if any, associated with file-name to be updated.
(See <xref linkend="sec7.i.o"/> in this Chapter).
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE OPEN STATEMENT</title>
      <indexterm>
        <primary>OPEN Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, OPEN</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
     The OPEN statement initiates the processing of files. It also performs
checking and/or writing of labels and other input-output operations.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg choice="plain">OPEN</arg>
          <group choice="req" rep="repeat">
            <arg choice="plain">
              <arg choice="plain">INPUT <replaceable>file-name-1</replaceable></arg>
              <arg choice="opt" rep="repeat">, <replaceable>file-name-2</replaceable></arg>
            </arg>
            <arg choice="plain">
              <arg choice="plain">OUTPUT <replaceable>file-name-3</replaceable></arg>
              <arg choice="opt" rep="repeat">, <replaceable>file-name-4</replaceable></arg>
            </arg>
            <arg choice="plain">
              <arg choice="plain">I-O <replaceable>file-name-5</replaceable></arg>
              <arg choice="opt" rep="repeat">, <replaceable>file-name-6</replaceable></arg>
            </arg>
          </group>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
The files referenced in the OPEN statement need not all have the same
organization or access.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The successful execution of the OPEN statement determines the
availability of the file and results in the file being in an open mode.
</para>
          </listitem>
          <listitem>
            <para>
The successful execution of the OPEN statement makes the associated
record area available to the program.
</para>
          </listitem>
          <listitem>
            <para>
Prior to the successful execution of an OPEN statement for a given
file, no statement can be executed that references that file, either
explicitly or implicitly.
</para>
          </listitem>
          <listitem>
            <para>
An OPEN statement must be successfully executed prior to the execution
of any of the permissible input-output statements. In Table 7-1,
Permissible Statements, 'X' at an intersection indicates that the
specified statement, used in the access mode given for that row, may be
used with the indexed file organisation and the open mode given at the
top of the column.
     </para>
            <table>
              <title>Permissible Combinations of Statements and Open Modes for Indexed I/O</title>
              <tgroup cols="5">
                <colspec colwidth="1.0in" colname="c1"/>
                <colspec colwidth="1.0in" colname="c2"/>
                <colspec colwidth="1.0in" colname="c3"/>
                <colspec colwidth="1.0in" colname="c4"/>
                <colspec colwidth="1.0in" colname="c5"/>
                <thead>
                  <row>
                    <entry morerows="1">File Access Mode</entry>
                    <entry morerows="1">Statement</entry>
                    <entry namest="c3" nameend="c5">Open Mode</entry>
                  </row>
                  <row>
                    <entry>Input</entry>
                    <entry>Output</entry>
                    <entry>Input-Output</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry morerows="4">Sequential</entry>
                    <entry>READ</entry>
                    <entry>X</entry>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>WRITE</entry>
                    <entry/>
                    <entry>X</entry>
                    <entry/>
                  </row>
                  <row>
                    <entry>REWRITE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>START</entry>
                    <entry>X</entry>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>DELETE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry morerows="4">Random</entry>
                    <entry>READ</entry>
                    <entry>X</entry>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>WRITE</entry>
                    <entry/>
                    <entry>X</entry>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>REWRITE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>START</entry>
                    <entry/>
                    <entry/>
                    <entry/>
                  </row>
                  <row>
                    <entry>DELETE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry morerows="4">Dynamic</entry>
                    <entry>READ</entry>
                    <entry>X</entry>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>WRITE</entry>
                    <entry/>
                    <entry>X</entry>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>REWRITE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>START</entry>
                    <entry>X</entry>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>DELETE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </listitem>
          <listitem>
            <para>
A file may be opened with the INPUT, OUTPUT and I-O phrases in the same
program. Following the initial execution of an OPEN statement for a
file, each subsequent OPEN statement execution for that same file must
be preceded by the execution of a CLOSE statement for that file.
</para>
          </listitem>
          <listitem>
            <para>
Execution of the OPEN statement does not obtain or release the first data record.
</para>
          </listitem>
          <listitem>
            <para>
The assigned name in the select statement for a file is processed as follows:
</para>
            <orderedlist>
              <listitem>
                <para>
When the INPUT phrase is specified , the execution of the OPEN
statement causes the assigned name to be checked in accordance
with the operating system conventions for opening files for input.
</para>
              </listitem>
              <listitem>
                <para>
When the OUTPUT phrase is specified, the execution of the OPEN
statement causes the assigned name to be written in accordance
with the opera ting system conventions for opening files for output.
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
      The file description entry for file-name-1 , file-name-2, file-name-5,
        or file-name-6 must be equivalent to that used when this file was created.
</para>
          </listitem>
          <listitem>
            <para>
For files being opened with the INPUT or I-O phrase, the OPEN statement
sets the current record pointer to the first record currently existing
within the file. If no records exist in the file, the current record
pointer is set such that the next executed Format 1 READ statement for
the file will result in an AT END condition.
<phrase role="extension">If the file does not exist, INPUT will cause an error status.</phrase>
</para>
          </listitem>
          <listitem>
            <para>
The I-O phrase permits the opening of a file for both input and out put
operations. <phrase role="extension">If the file does not exist, it will be created.</phrase>
</para>
          </listitem>
          <listitem>
            <para>
Upon successful execution of an OPEN statement with the OUTPUT phrase
specified, a file is created. At that time the associated file
contains no data records. <phrase role="extension">If a file of the same name exists it will be
deleted. If write protected, an error status occurs.</phrase>
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE READ STATEMENT</title>
      <indexterm>
        <primary>READ Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, READ</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
For sequential access, the READ statement makes available the next
logical record from a file. For random access, the READ statement makes
available a specified record from a mass storage file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <para>
     Format 1
     </para>
        <cmdsynopsis>
          <command>READ</command>
          <arg>file-name</arg>
          <arg choice="opt">NEXT</arg>
          <arg>RECORD</arg>
          <arg choice="opt">INTO identifier</arg>
          <arg choice="opt">; AT END imperative-statement</arg>
        </cmdsynopsis>
        <para>
Format 2
</para>
        <cmdsynopsis>
          <command>READ</command>
          <arg>file-name</arg>
          <arg>RECORD</arg>
          <arg choice="opt">INTO identifier</arg>
          <arg choice="opt">;INVALID KEY imperative-statement</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
The INTO phrase must not be used when the input file contains logical
records of various sizes as indicated by their record descriptions.
The storage area associated with identifier and the storage area which
is the record area associated with file-name must not be the same
storage area.
</para>
          </listitem>
          <listitem>
            <para>
Format 1 must be used (without the NEXT phrase) for all files in sequential access mode.
</para>
          </listitem>
          <listitem>
            <para>
Format 2 is used for files in random access mode or for files in
          dynamic access mode when records are to be retrieved randomly.
</para>
          </listitem>
          <listitem>
            <para>
The NEXT phrase must be specified for files in dynamic access mode,
          when records are to be retrieved sequentially.
</para>
          </listitem>
          <listitem>
            <indexterm>
              <primary>Conditions, INVALID KEY</primary>
            </indexterm>
            <indexterm>
              <primary>INVALID KEY Condition</primary>
            </indexterm>
            <para>
The INVALID KEY phrase or the AT END phrase must be specified if no
          applicable USE procedure is specified for file-name.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The associated file must be open in the INPUT or I-O mode at the time
          this statement is executed. (See THE OPEN STATEMENT in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
The record to be made available by a Format 1 READ statement is
          determined as follows:
</para>
            <orderedlist>
              <listitem>
                <para>
The record, pointed to by the current record pointer, is made
available provided that the current record pointer was positioned
by the START or OPEN statement and the record is still accessible
through the path indicated by the current record pointer; if the
record is no longer accessible, which may have been caused by the
deletion of the record, the current record pointer is updated to
point to the next existing record in key sequence and that record
is then made available.
</para>
              </listitem>
              <listitem>
                <para>
If the current record pointer was positioned by the execution of a
previous READ statement, the current record pointer is updated to
point to the next existing record in the file in key sequence and
then that record is made available.
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
The execution of the READ statement causes the value of the FILE STATUS
data item, if any, associated with file-name to be updated.
(See <xref linkend="sec7.i.o"/> in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
Regardless of the method used to overlap access time with processing
time, the concept of the READ statement is unchanged in that a record
is available to the object program prior to the execution of any
statement following the READ statement.
</para>
          </listitem>
          <listitem>
            <para>
When the logical records of a file are described with more than one
record description, these records automatically share the same storage
area; this is equivalent to an implicit redefinition of the area. The
contents of any data items which lie beyond the range of the current
data record are undefined at the completion of the execution of the
READ statement.
</para>
          </listitem>
          <listitem>
            <para>
If the INTO phrase is specified, the record being read is moved from
the record area to the area specified by identifier according to the
rules specified for the MOVE statement. The implied MOVE does not
occur if the execution of the READ statement was unsuccessful. Any
subscripting or indexing associated with identifier is evaluated after
the record has been read and immediately before it is moved to the data item.
</para>
          </listitem>
          <listitem>
            <para>
When the INTO phrase is used, the record being read is available in
both the input record area and the data area associated with
identifier.
</para>
          </listitem>
          <listitem>
            <para>
If, at the time of execution of a Format 1 READ statement, the position
of current record pointer for that file is undefined, the execution of
that READ statement is unsuccessful.
</para>
          </listitem>
          <listitem>
            <para>
If, at the time of the execution of a Format 1 READ statement, no next
logical record exists in the file, the AT END condition occurs, and the
execution of the READ statement is considered unsuccessful.
(See <xref linkend="sec7.i.o"/> in this Chapter).                                             -
</para>
          </listitem>
          <listitem>
            <para>
When the AT END condition is recognised the following actions are taken
in the specified order:
</para>
            <orderedlist>
              <listitem>
                <para>
A value is placed into the FILE STATUS data item, if specified for
this file, to indicate an AT END condition.
(See <xref linkend="sec7.i.o"/> in this Chapter).
</para>
              </listitem>
              <listitem>
                <para>
If the AT END phrase is specified in the statement causing the
condition, control is transferred to the AT END imperative
statement. Any USE procedure specified for this file is not executed.
</para>
              </listitem>
              <listitem>
                <para>
If the AT END phrase is not specified, then a USE procedure must
be specified, either explicitly or implicitly, for this file, and
that procedure is executed,
</para>
                <para>
When the AT END condition occurs, execution of the input-output
statement which caused the condition is unsuccessful.
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
Following the unsuccessful execution of any READ statement, the
contents of the associated record area and the position of the current
record pointer are undefined.
</para>
          </listitem>
          <listitem>
            <para>
When the AT END condition has been recognised, a Format 1 READ
statement for that file must not be executed without first executing
one of the following:
</para>
            <orderedlist>
              <listitem>
                <para>
A successful CLOSE statement followed by the execution of a
successful OPEN statement for that file.
</para>
              </listitem>
              <listitem>
                <para>
A successful START statement for that file.
</para>
              </listitem>
              <listitem>
                <para>
A successful Format 2 READ statement for that file.
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
For a file which dynamic access mode is specified, a Format 1 READ
statement with the NEXT phrase specified causes the next logical record
to be retrieved from that file as described in general rule 2 above.
</para>
          </listitem>
          <listitem>
            <para>
Execution of a Format 2 READ statement causes the value of the key that
to be compared with the value contained in the corresponding data item
of the stored records in the file, until the first record has an equal
value is found. The current record pointer is positioned to this
record which is then made available. If no record can be so
identified, the INVALID KEY condition exists and execution of the READ
statement is unsuccessful. (See <xref linkend="sec7.inv.key"/> in this
Chapter).
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE REWRITE STATEMENT</title>
      <indexterm>
        <primary>REWRITE Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, REWRITE</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The REWRITE statement logically replaces a record existing in a mass
storage file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <command>REWRITE</command>
          <arg>record-name</arg>
          <arg choice="opt">FROM identifier</arg>
          <arg choice="opt">; INVALID KEY imperative-statement</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
Record-name and  identifier must not refer to the same storage area.
</para>
          </listitem>
          <listitem>
            <para>
Record-name is the name of a logical record in the File Section of the Data Division.
</para>
          </listitem>
          <listitem>
            <para>
The INVALID KEY phrase must be specified in the REWRITE statement for
      files for which an appropriate USE procedure is not specified.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The file associated with record-name must be open in the I-O mode at
the time of execution of this statement. (See THE OPEN STATEMENT in this Chapter)
</para>
          </listitem>
          <listitem>
            <para>
For files in the sequential access mode, the last input-output
statement executed for the associated file prior to the execution of
the REWRITE statement must have been a successfully executed READ
statement. The Operating System logically replaces the record that was
accessed by the READ statement.
</para>
          </listitem>
          <listitem>
            <para>
The number of character positions in the record referenced by
record-name must be equal to the number of character positions in the
record being replaced.
</para>
          </listitem>
          <listitem>
            <para>
The logical record released by a successful execution of the REWRITE
statement is no longer available in the record area.
</para>
          </listitem>
          <listitem>
            <para>
The execution of a REWRITE statement with the FROM phrase is equivalent
to the execution of:
      </para>
            <screen>
        MOVE identifier TO record-name
      </screen>
            <para>
followed by the execution of the same REWRITE statement without the
FROM phrase. The contents of the record area prior to the execution of
the implicit MOVE statement have no effect on the execution of the
REWRITE statement.
</para>
          </listitem>
          <listitem>
            <para>
The current record pointer is not affected by the execution of a REWRITE statement.
</para>
          </listitem>
          <listitem>
            <para>
The execution of the REWRITE statement causes the value of the FILE
STATUS data item, if any, associated with the file to be updated.
(See <xref linkend="sec7.i.o"/>).
</para>
          </listitem>
          <listitem>
            <para>
For a file in the sequential access mode, the record to be replaced is
specified by the value contained in the record key. When the REWRITE
statement is executed the value contained in the record key data item
of the record to be replaced must be equal to the value of the record
key of the last record read from this file.
</para>
          </listitem>
          <listitem>
            <para>
For a file in the random or dynamic access mode, the record to be
replaced is specified by the record key data item.
</para>
          </listitem>
          <listitem>
            <para>
The INVALID KEY condition exists when:
</para>
            <orderedlist>
              <listitem>
                <para>
The access mode is sequential and the value contained in the
record key data item of the record to be replaced is not equal to
the value of the record key of the last record read from this file or,
</para>
              </listitem>
              <listitem>
                <para>
The value contained in the record key data item does not equal
that of any record stored in the file, or
</para>
              </listitem>
              <listitem>
                <para>
The updating operation does not take place and the data in the
record area is unaffected. (See <xref linkend="sec7.inv.key"/> in this Chapter).
</para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE START STATEMENT</title>
      <indexterm>
        <primary>START Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, START</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
         The START statement provides a basis for logical positioning within an
indexed file, for subsequent sequential retrieval of records.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>START file-name</arg>
          <arg choice="opt">
            <arg>KEY</arg>
            <group>
              <arg>IS EQUAL TO</arg>
              <arg>IS =</arg>
              <arg>IS GREATER THAN</arg>
              <arg>IS &gt;</arg>
              <arg>IS NOT LESS THAN</arg>
              <arg>IS NOT &lt;</arg>
            </group>
            <arg>data-name</arg>
            <sbr/>
            <arg choice="opt">;INVALID KEY imperative-statement</arg>
          </arg>
        </cmdsynopsis>
        <para>
NOTE: The required relational characters '&gt;', '&lt;' and '=' are not
underlined to avoid confusion with other symbols such as '&#x2265;'
(greater than or equal to).
</para>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
File-name must be the name of an indexed file.
</para>
          </listitem>
          <listitem>
            <para>
File-name must be the name of a file with sequential or dynamic access.
</para>
          </listitem>
          <listitem>
            <para>
The INVALID KEY phrase must be specified if no applicable USE procedure
         is specified for file-name.
</para>
          </listitem>
          <listitem>
            <para>
If file-name is the name of an indexed file, and if a KEY phrase is
specified, data-name may reference a data item specified as the record
key associated with file-name, or it may reference any data item of
category alphanumeric subordinate to the data-name of a data item
specified as the record key associated with file-name whose leftmost
character position corresponds to the leftmost character position of
that record key data item.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
File-name must be open in the INPUT or I-O mode at the time that the
START statement is executed, (See THE OPEN STATEMENT in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
If the KEY phrase is not specified, 'IS EQUAL TO' is implied.
</para>
          </listitem>
          <listitem>
            <para>
The type of comparison specified by the relational operator in the KEY
phrase occurs between a key associated with a record in the file
referenced by file-name and a data item as specified in general rule 5.
If file-name references an indexed file and the operands are of unequal
size, comparison proceeds as though the longer one were truncated on
the right such that its length is equal to that of the shorter. All
other nonnumeric comparison rules apply except that the presence of the
PROGRAM COLLATING SEQUENCE clause will have no effect on the
comparison. (See Comparison of Nonnumeric Operands).
</para>
            <orderedlist>
              <listitem>
                <para>
The current record pointer is positioned to the first logical
             record currently existing in the file whose key satisfies the
             comparison.
</para>
              </listitem>
              <listitem>
                <para>
If the comparison is not satisfied by any record in the f11.e, an
           INVALID KEY condition exists, the execution of the START statement
             is unsuccessful, and the position of the current record pointer is
             undefined. (See <xref linkend="sec7.inv.key"/> in this Chapter)
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
The execution of the START statement causes the value of the FILE
        STATUS data item, if any, associated with file-name to be updated.
        (See <xref linkend="sec7.i.o"/>).
</para>
          </listitem>
          <listitem>
            <para>
If the KEY phrase is specified, the comparison described in general
        rule 3 uses the data item referenced by data-name.
</para>
          </listitem>
          <listitem>
            <para>
If the KEY phrase is not specified, the comparison described in general
rule 3 uses ti1e data item referenced in the RECORD KEY clause
associated with file-name.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE USE STATEMENT</title>
      <indexterm>
        <primary>USE Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, USE</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
     The USE statement specifies procedures for input-output error handling
that are in addition to the standard procedures provided by the input-output
control system.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <command>USE  AFTER STANDARD</command>
          <group choice="req">
            <arg>EXCEPTION</arg>
            <arg>ERROR</arg>
          </group>
          <arg>PROCEDURE ON</arg>
          <group choice="req">
            <arg>file-name-1</arg>
            <arg>INPUT</arg>
            <arg>OUTPUT</arg>
            <arg>I-O</arg>
          </group>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
A USE statement, when present, must immediately follow a section header
      in the declaratives section and must be followed by a period followed
      by a space. The remainder of the section must consist of zero, one or
      more procedural paragraphs that define the procedures to be used.
</para>
          </listitem>
          <listitem>
            <para>
The USE statement itself is never executed; i t merely defines the
      conditions calling for the execution of the USE procedures.
</para>
          </listitem>
        </orderedlist>
        <para>
 General Rules
</para>
        <orderedlist>
          <listitem>
            <para>
If the INVALID KEY phrase on the AT END phrase have not been specified
      in the input-output statements the designated procedures are executed
      by the input-output system after completing the standard input-output
      routine upon recognition of the INVALID KEY or AT END condition.
</para>
          </listitem>
          <listitem>
            <para>
After execution of a USE procedure, control is returned to the invoking
      routine.
</para>
          </listitem>
          <listitem>
            <para>
Within a USE procedure, there must not be any reference to any
      nondeclarative procedures. Conversely, in the nondeclarative portion
      there must be no reference to procedure-names that appear in the
      declarative portion, except that PERFORM statements may refer to a USE
      statement or to the procedures associated with such a USE statement.
</para>
          </listitem>
          <listitem>
            <para>
Within a USE procedure, there must not be the execution of any
      statement that would cause the execution of a USE procedure that had
      previously been invoked and had not yet returned control to the
      invoking routine.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE WRITE STATEMENT</title>
      <indexterm>
        <primary>WRITE Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, WRITE</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
       The WRITE statement releases a logical record for an output or input-output file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <command>WRITE</command>
          <arg>record-name</arg>
          <arg choice="opt">FROM identifier</arg>
          <arg choice="opt">; INVALID KEY imperative-statement</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
Record-name and identifier must not reference the same storage area.
</para>
          </listitem>
          <listitem>
            <para>
The record-name is the name of a logical record in the File Section of
       the Data Division.
</para>
          </listitem>
          <listitem>
            <para>
The INVALID KEY phrase must be specified if an applicable USE procedure
       is not specified for the associated file.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The associated file must be open in the OUTPUT or I-O mode at the time
of the execution of this statement. (See THE OPEN STATEMENT in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
The logical record released by the execution of the WRITE statement is
no longer available in the record area unless the execution of the
WRITE statement is unsuccessful due to an INVALID KEY condition.
</para>
          </listitem>
          <listitem>
            <para>
The results of the execution of the WRITE statement with the FROM
phrase is equivalent tn the execution of:
</para>
            <orderedlist>
              <listitem>
                <para>
          The statement:
       <programlisting>
       MOVE identifier TO record-name
   </programlisting>
according to the rules specified for the MOVE statement, followed  by:
</para>
              </listitem>
              <listitem>
                <para>
The same WRITE statement without the FROM phrase.
</para>
                <para>
The contents of the record area prior to the execution of the
implicit MOVE statement have no effect on the execution of this WRITE statement.
</para>
                <para>
After execution of the WRITE statement is complete, the
information in the area referenced by identifier is available,
even though the information in the area referenced by record-name
may not be. (See general rule 2 above).
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
The current record pointer is unaffected by the execution of a WRITE statement.
</para>
          </listitem>
          <listitem>
            <para>
The execution of the WRITE statement causes the value of the FILE
     STATUS data item, if any, associated with the file to be updated. (See
     <xref linkend="sec7.i.o"/> in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
The maximum record size for a file is established at the time the file
     is created and must not subsequently be changed.
</para>
          </listitem>
          <listitem>
            <para>
The number of character positions on a mass storage device required to
     store a logical record in a file may or may not be equal to the number
     of character positions defined by the logical description of that
     record in the program.
</para>
          </listitem>
          <listitem>
            <para>
The execution of the WRITE statement releases a logical record to the operating system.
</para>
          </listitem>
          <listitem>
            <para>
Execution of the WRITE statement causes the contents of the record area
to be released. The Operating System utilizes the content of the
record key in such a way that subsequent access of the record may be
made based upon the specified record key.
</para>
          </listitem>
          <listitem>
            <para>
The value of the record key must be unique within the records in the file.
</para>
          </listitem>
          <listitem>
            <para>
The data item specified as the record key must be set by the program to
the desired value prior to the execution of the WRITE statement.
</para>
          </listitem>
          <listitem>
            <para>
If sequential access mode is specified for the file, records must be
released to the Operating System is ascending order of record key values.
</para>
          </listitem>
          <listitem>
            <para>
If random or dynamic access mode is specified, records may be released
to the Operating System in any program-specified order.
</para>
          </listitem>
          <listitem>
            <para>
The INVALID KEY condition exists under the following circumstances:
</para>
            <orderedlist>
              <listitem>
                <para>
When sequential access mode is specified for a file opened in the
output mode, and the value of the record key is not greater than
the value of the record key of the previous record, or
</para>
              </listitem>
              <listitem>
                <para>
When the file is opened in the output or I-O mode, and the value
of the record key is equal to the value of a record key of a
record already existing in the file, or
</para>
              </listitem>
              <listitem>
                <para>
When an attempt is made to write beyond the externally defined boundaries of the file.
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
When the INVALID KEY condition is recognised the execution of the WRITE
statement is unsuccessful, the contents of the record area are
unaffected and the FILE STATUS data item, if any, associated with
file-name of the associated file is set to a value indicating the cause
of the condition. Execution of the program proceeds according to the
rules stated under <xref linkend="sec7.inv.key"/>
(See also <xref linkend="sec7.i.o"/> in this Chapter).
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
  </section>
</chapter>
