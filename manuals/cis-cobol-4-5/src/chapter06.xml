<?xml version="1.0"?>
<chapter xmlns="http://docbook.org/ns/docbook">
  <title>RELATIVE INPUT AND OUTPUT</title>
  <section>
    <title>INTRODUCTION TO THE RELATIVE I-O MODULE</title>
    <para>
The Relative I-O module provides a capability to access records of a mass
storage file in either a random or sequential manner. Each record in a
relative file is uniquely identified by an integer value greater than zero
which specifies the record's ordinal position in the file.
(See the <citetitle pubwork="book">CIS COBOL Operating Guide</citetitle>
for the maximum number of records in a relative file.)
</para>
    <section>
      <title>LANGUAGE CONCEPTS</title>
      <indexterm>
        <primary>Language Concepts</primary>
      </indexterm>
      <section>
        <title>Organization</title>
        <indexterm>
          <primary>Organisation, Relative</primary>
        </indexterm>
        <para>
Relative file organization is permitted only on disk devices. A relative
file consists of records which are identified by relative record numbers.
The file may be thought of as composed of a serial string of areas, each
capable of holding a logical record. Each of these areas is denominated by
a relative record number. Records are stored and retrieved based on this
number. For example, the tenth record is the one addressed by relative
record number 10 and is in the tenth record area, whether or not records
have been written in the first through the ninth record areas.
</para>
      </section>
      <section>
        <title>Access Modes</title>
        <indexterm>
          <primary>Access Mode</primary>
        </indexterm>
        <indexterm>
          <primary>Mode, Access</primary>
        </indexterm>
        <para>
In the sequential access mode, the sequence in which records are accessed is
the ascending order of the relative record numbers of all records which
currently exist within the file.
In the random access mode, the sequence in which records are accessed is
controlled by the programmer. The desired record is accessed by placing its
relative record number in a relative key data item.
In the dynamic access mode, the programmer may change at will from
sequential access to random access using appropriate forms of input-output
statements.
</para>
      </section>
      <section>
        <title>Current Record Pointer</title>
        <indexterm>
          <primary>Current Record Pointer</primary>
        </indexterm>
        <indexterm>
          <primary>Record Pointer, Current</primary>
        </indexterm>
        <para>
The current record printer is a conceptual entity used in this document to
facilitate specification of the next record to be accessed within a given
file. The concept of the current record pointer has no meaning for a file
opened in the output mode. The setting of the current record pointer is
affected only by the OPEN, START and READ statements.
</para>
      </section>
      <section xml:id="sec6.i.o">
        <title>I-O Status</title>
        <indexterm>
          <primary>Input-Output Status</primary>
        </indexterm>
        <indexterm>
          <primary>Status, Input-Output</primary>
        </indexterm>
        <para>
If the FILE STATUS clause is specified in a file control entry, a value is
placed into the specified two-character data item during the execution of an
OPEN, CLOSE, READ, WRITE, REWRITE, DELETE or START statement and before any
applicable USE procedure is executed, to indicate to the COBOL program the
status of that input-output operation.
</para>
        <section>
          <title>Status Key 1</title>
          <indexterm>
            <primary>Status Keys</primary>
          </indexterm>
          <indexterm>
            <primary>Keys, Status</primary>
          </indexterm>
          <para>
The leftmost character position of the FILE STATUS data item is known
as Status Key 1 and is set to indicate one of the following conditions upon
completion of the input-output operation.
</para>
          <itemizedlist mark="none" spacing="compact">
            <listitem>
              <para>
            '0' -     indicates Successful Completion
          </para>
            </listitem>
            <listitem>
              <para>
            '1' -    indicates At End
          </para>
            </listitem>
            <listitem>
              <para>
            '2' -    indicates Invalid Key
          </para>
            </listitem>
            <listitem>
              <para>
            '3' -     indicates Permanent Error
          </para>
            </listitem>
            <listitem>
              <para>
            '9' -     indicates an Operating System Error Message
          </para>
            </listitem>
          </itemizedlist>
          <para>
     The meaning of the above indications are as follows:
</para>
          <variablelist>
            <varlistentry>
              <term>0</term>
              <listitem>
                <para>Successful Completion. The input-output statement was
               successfully executed.
               </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>1</term>
              <listitem>
                <para>At End. The Format 1 READ statement was unsuccessfully
               executed as a result of an attempt to read a record when no
               next logical record exists in the file.
               </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>2</term>
              <listitem>
                <para>Invalid Key. The input-output statement was unsuccessfully
              executed as a result of one of the following:
          </para>
                <itemizedlist spacing="compact">
                  <listitem>
                    <para>
Duplicate Key
               </para>
                  </listitem>
                  <listitem>
                    <para>
No Record Found
               </para>
                  </listitem>
                  <listitem>
                    <para>
Boundary Violation
               </para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>3</term>
              <listitem>
                <para>Permanent Error. The input-output statement was unsuccessfully
              executed as the result of an input-output error, such as data
              check, parity error or transmission error.
               </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>9</term>
              <listitem>
                <para>Operating System Error Message. The input-output statement
               was unsuccessfully executed as a result of a condition that
               is specified by the Operating System Error Message. This
               value is used only to indicate a condition not indicated by
               other defined values of status key 1, or by specified
               combinations of the values of status key 1 and status key 2.
               </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>Status Key 2</title>
          <para>
The rightmost character position of the FILE STATUS data item is known
as status key 2 and is used to further describe the results of the
input-output operation. This character contains a value as follows:
   </para>
          <itemizedlist>
            <listitem>
              <para>
If no further information is available concerning the input-output
operation, then status key 2 contains a value of '0'
</para>
            </listitem>
            <listitem>
              <para>
When status key 1 contains a value of '2' indicating an INVALID
KEY condition, status key 2 is used to designate the cause of that
condition by the following values:
</para>
              <variablelist termlength="3" spacing="compact">
                <varlistentry>
                  <term>2 -</term>
                  <listitem>
                    <para>Indicates a duplicate key value. An attempt has been
                     made to write a record that would create a duplicate key
                     in a relative file.
</para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>3 -</term>
                  <listitem>
                    <para>Indicates no record found. An attempt has been made to
                     access a record, identified by a key, and that record
                     does not exist in the file,
</para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>4 -</term>
                  <listitem>
                    <para>Indicates a boundary violation. An attempt has been
                     made to write beyond the externally-defined boundaries
                     of a relative file. This is normally treated as a fatal
                     error by the Operation System.
</para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
            <listitem>
              <para>
When status key 1 contains a value of '9' the value of status key 2
is the operating system error message number (for those
operating systems which designate errors numerically),
The <citetitle pubwork="book">CIS COBOL Operating Guide</citetitle>
specific to your operating system contains
details of the status-key-2 representation.
Note that it is not possible to extract this number directly.
</para>
            </listitem>
          </itemizedlist>
        </section>
        <section>
          <title>Valid Combinations of Status Keys 1 and 2</title>
          <para>
The valid permissible combinations of the values of status key 1 and
status key 2 are shown in the table. An 'X' at an intersection indicates a
valid permissible combination.
</para>
          <informaltable frame="all" colsep="1" rowsep="1">
            <tgroup cols="5">
              <colspec colwidth="1.2in" align="left" colname="c1"/>
              <colspec colwidth=".7in" align="left" colname="c2"/>
              <colspec colwidth=".7in" align="left" colname="c3"/>
              <colspec colwidth=".7in" align="left" colname="c4"/>
              <colspec colwidth=".7in" align="left" colname="c5"/>
              <tbody>
                <row>
                  <entry morerows="1">Status Key 1</entry>
                  <entry namest="c2" nameend="c5">Status Key 2</entry>
                </row>
                <row>
                  <entry>No Further Information (0)</entry>
                  <entry>Duplicate Key (2)</entry>
                  <entry>No Record Found (3)</entry>
                  <entry>Boundary Violation (4)</entry>
                </row>
                <row>
                  <entry>Successful Completion (0)</entry>
                  <entry>X</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry>At End (1)</entry>
                  <entry>X</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry>Invalid Key (2)</entry>
                  <entry/>
                  <entry>X</entry>
                  <entry>X</entry>
                  <entry>X</entry>
                </row>
                <row>
                  <entry>Permanent Error (3)</entry>
                  <entry>X</entry>
                  <entry/>
                  <entry/>
                  <entry/>
                </row>
                <row>
                  <entry>Implementor Defined (9)</entry>
                  <entry namest="c2" nameend="c5">Operating System Error Message Number</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section xml:id="sec6.inv.key">
          <title>The INVALID KEY Condition</title>
          <para>
The INVALID KEY condition can occur as a result of the execution of a START,
READ, WRITE, REWRITE or DELETE statement. For details of the causes of the
condition, see The START Statement, The READ Statement, The WRITE Statement,
The REWRITE Statement, and The DELETE Statement later in this chapter.
</para>
          <para>
When the INVALID KEY condition is recognised, the Operating System takes
these actions in the following order:
</para>
          <orderedlist>
            <listitem>
              <para>
A value is placed into the FILE STATUS data item, if specified for this
file, to indicate an INVALID KEY condition.   (See <xref linkend="sec6.i.o"/> in this Chapter).
</para>
            </listitem>
            <listitem>
              <para>
If the INVALID KEY phrase is specified in the statement causing the
condition, control is transferred to the INVALID KEY imperative
statement. Any USE procedure specified for this file is not executed.
</para>
            </listitem>
            <listitem>
              <para>
If  the INVALID KEY phrase is not specified, but a USE procedure is
specified, either explicitly or implicitly, for this file, that
procedure is executed.
</para>
            </listitem>
          </orderedlist>
          <para>
When the INVALID KEY condition occurs, execution of the input-output
statement which recognised the condition is unsuccessful, and the file is
not affected.
</para>
        </section>
        <section>
          <title>The AT END Condition</title>
          <indexterm>
            <primary>AT END Condition</primary>
          </indexterm>
          <indexterm>
            <primary>Conditions, AT END</primary>
          </indexterm>
          <para>
The AT END condition can occur as a result of the execution of a READ
statement. For details of the causes of the condition,
see The READ Statement later in this chapter.
</para>
        </section>
      </section>
    </section>
  </section>
  <section>
    <title>ENVIRONMENT DIVISION IN THE RELATIVE I-O MODULE</title>
    <indexterm>
      <primary>Environment Division in Relative</primary>
    </indexterm>
    <indexterm>
      <primary>Relative I-O Module, Environment Division</primary>
    </indexterm>
    <section>
      <title>INPUT-OUTPUT SECTION</title>
      <indexterm>
        <primary>Input-Output Section</primary>
      </indexterm>
      <indexterm>
        <primary>Section, Input-Output</primary>
      </indexterm>
      <section>
        <title>The File-Control Paragraph</title>
        <indexterm>
          <primary>FILE-CONTROL Paragraph</primary>
        </indexterm>
        <indexterm>
          <primary>Paragraph, FILE-CONTROL</primary>
        </indexterm>
        <section>
          <title>Function</title>
          <para>
       The FILE-CONTROL paragraph names each file and allows specification of
other file-related information. (See also Appendix F in the
<citetitle pubwork="book">CIS COBOL Operating Guide</citetitle>).
</para>
        </section>
        <section>
          <title>General Format</title>
          <cmdsynopsis>
            <command>FILE-CONTROL</command>
            <arg choice="req" rep="repeat">file-control-entry</arg>
          </cmdsynopsis>
        </section>
      </section>
      <section>
        <title>The File-Control Entry</title>
        <indexterm>
          <primary>FILE-CONTROL Entry</primary>
        </indexterm>
        <indexterm>
          <primary>Entry, FILE-CONTROL</primary>
        </indexterm>
        <indexterm>
          <primary>SELECT Clause</primary>
        </indexterm>
        <indexterm>
          <primary>Clause, SELECT</primary>
        </indexterm>
        <section>
          <title>Function</title>
          <para>
The file control entry names a file and may specify other file-related information.
</para>
        </section>
        <section>
          <title>General Format</title>
          <indexterm>
            <primary>FILE STATUS Clause</primary>
          </indexterm>
          <indexterm>
            <primary>Clause, FILE STATUS</primary>
          </indexterm>
          <cmdsynopsis>
            <command>SELECT</command>
            <arg>file-name</arg>
            <sbr/>
            <arg>ASSIGN TO</arg>
            <group choice="req">
              <arg>external-file-name-literal</arg>
              <arg>file-identifier</arg>
            </group>
            <arg choice="opt">
              <arg>,</arg>
              <group choice="req">
                <arg>external-file-name-literal</arg>
                <arg>file-identifier</arg>
              </group>
            </arg>
            <sbr/>
            <arg>; ORGANIZATION IS RELATIVE</arg>
            <sbr/>
            <arg choice="opt">
              <arg>; ACCESS MODE IS</arg>
              <group choice="req">
                <arg>SEQUENTIAL ,RELATIVE KEY IS data-name</arg>
                <arg>
                  <group choice="req">
                    <arg>RANDOM</arg>
                    <arg>DYNAMIC</arg>
                  </group>
                  <arg>,RELATIVE KEY IS data-name</arg>
                </arg>
              </group>
            </arg>
            <sbr/>
            <arg choice="opt">; FILE STATUS IS data-name-2</arg>
          </cmdsynopsis>
        </section>
        <section>
          <title>Syntax Rules</title>
          <orderedlist>
            <listitem>
              <para>
The SELECT clause must be specified first in the file control entry.
The clauses which follow the SELECT clause may appear in any order.
</para>
            </listitem>
            <listitem>
              <para>
Each file described in the Data Division must be named once and only
once as file-name in the FILE-CONTROL paragraph. Each file specified
in the file control entry must have a file description entry in the Data Division.
</para>
            </listitem>
            <listitem>
              <para>
If the ACCESS MODE clause is not specified, the ACCESS MODE IS
SEQUENTIAL clause is implied.
</para>
            </listitem>
            <listitem>
              <para>
Data-name-2 must be defined in the Data Division as a two-character
data item of the category alphanumeric and must not be defined in the
File Section, the Report Section, or the Communication Section.
</para>
            </listitem>
            <listitem>
              <para>
Data-name-1 must not be defined in a record description entry
associated with that file-name.
</para>
            </listitem>
            <listitem>
              <para>
The data item referenced by data-name-1 must be defined as an unsigned integer.
</para>
            </listitem>
          </orderedlist>
        </section>
        <section>
          <title>General Rules</title>
          <indexterm>
            <primary>ASSIGN Clause</primary>
          </indexterm>
          <indexterm>
            <primary>Clause, ASSIGN</primary>
          </indexterm>
          <orderedlist>
            <listitem>
              <para>
The ASSIGN clause specifies the association of the file referenced by file-name to a storage medium.
See Appendix F in the <citetitle pubwork="book">CIS COBOL Operating Guide</citetitle>.
<phrase role="extension">The first assignment takes place.
Subsequent assignments within any one ASSIGN clause are for documentation purposes only.</phrase>
</para>
            </listitem>
            <listitem>
              <indexterm>
                <primary>ORGANIZATION IS RELATIVE</primary>
              </indexterm>
              <indexterm>
                <primary>Clause, ORGANIZATION</primary>
              </indexterm>
              <para>
The  ORGANIZATION clause specifies the logical structure of a file. The
file organization is established at the time a file is created and
cannot subsequently be changed.
</para>
            </listitem>
            <listitem>
              <para>
When the access mode is sequential , records in the file are accessed in
the sequence dictated by the file organization. This sequence is the
order of ascending relative record numbers of existing records in the file.
</para>
            </listitem>
            <listitem>
              <para>
When the FILE STATUS clause is specified, a value will be moved by the
operating system into the data item specified by data-name-2 after the
execution of every statement that references that file either
explicitly or implicitly. This value indicates the status of execution
of the statement. (See <xref linkend="sec6.i.o"/> in this Chapter).
</para>
            </listitem>
            <listitem>
              <para>
If the access mode is random, the value of the RELATIVE KEY data item
indicates the record to be accessed.
</para>
            </listitem>
            <listitem>
              <para>
When the access made is dynamic, records in the file may be assessed
sequentially and/or randomly. (See General Rules 3 and 5) .
</para>
            </listitem>
            <listitem>
              <para>
All records stored in a relative file are uniquely identified by
relative record numbers. The relative record number of a given record
specifies the record's logical ordinal position in the file. The first
logical record has a relative record number of 1, and subsequent
logical records have relative record numbers of 2, 3, 4, ... .
</para>
            </listitem>
            <listitem>
              <para>
The data item specified by data-name-1 is used to communicate a
relative record number between the user and the Operating System.
</para>
            </listitem>
          </orderedlist>
        </section>
      </section>
      <section>
        <title>The I-O-CONTROL Paragraph</title>
        <indexterm>
          <primary>I-O Control Paragraph</primary>
        </indexterm>
        <indexterm>
          <primary>Paragraph, I-O CONTROL</primary>
        </indexterm>
        <section>
          <title>Function</title>
          <para>
The I-O-CONTROL paragraph specifies the points at which rerun is to be
established and the memory area which is to be shared by different files.
</para>
        </section>
        <section>
          <title>General Format</title>
          <cmdsynopsis>
            <command>I-O-CONTROL.</command>
            <arg choice="opt" rep="repeat">
              <arg>; RERUN</arg>
              <arg choice="opt">
                <arg>ON</arg>
                <group choice="req">
                  <arg>file-name-1</arg>
                  <arg>implementor-name</arg>
                </group>
              </arg>
              <arg>EVERY</arg>
              <group choice="req">
                <arg>integer-1 RECORDS OF file-name-2</arg>
                <arg>integer-2 CLOCK-UNITS</arg>
                <arg>condition-name</arg>
              </group>
            </arg>
            <arg choice="opt" rep="repeat">
              <arg>; SAME AREA FOR file-name-3</arg>
              <arg choice="opt" rep="repeat">, file-name-4</arg>
            </arg>
            <arg>.</arg>
          </cmdsynopsis>
        </section>
        <section>
          <title>Syntax Rules</title>
          <orderedlist>
            <listitem>
              <para>
The I-O-CONTROL paragraph is optional. <phrase role="extension">The whole clause is for
documentation purposes only.</phrase>
</para>
            </listitem>
            <listitem>
              <para>
File-name-1 must be a sequentially organized file.
</para>
            </listitem>
            <listitem>
              <para>
When either the integer-1 RECORDS clause or the integer-2 CLOCK-UNITS
clause is specified, implementor-name must be given in the RERUN clause.
</para>
            </listitem>
            <listitem>
              <para>
More than one RERUN clause may be specified for a given file-name-2,
subject to the following restriction:
      </para>
              <para>
When multiple integer-1 RECORDS clauses are specified, no two of
them may specify the same file-name-2.
</para>
            </listitem>
            <listitem>
              <para>
Only one RERUN clause containing the CLOCK-UNITS clause may be specified.
</para>
            </listitem>
            <listitem>
              <para>
More than one SAME clause may be included in a program but file-name
must not appear in more than one SAME AREA clause.
</para>
            </listitem>
            <listitem>
              <para>
The files referenced in the SAME AREA clause need not all have the same
organization or access.
</para>
            </listitem>
          </orderedlist>
        </section>
        <section>
          <title>General Rules</title>
          <orderedlist>
            <listitem>
              <para>
                <phrase role="extension">The RERUN clause is treated as for documentation purposes only.</phrase>
              </para>
            </listitem>
            <listitem>
              <para>
                <phrase role="extension">The SAME AREA clause is treated as for documentation purposes only.</phrase>
              </para>
            </listitem>
          </orderedlist>
        </section>
      </section>
    </section>
  </section>
  <section>
    <title>DATA DIVISION IN THE RELATIVE I-O MODULE</title>
    <indexterm>
      <primary>Data Division in Relative</primary>
    </indexterm>
    <indexterm>
      <primary>Relative I-O Module, Data Division</primary>
    </indexterm>
    <section>
      <title>FILE SECTION</title>
      <indexterm>
        <primary>FILE Section</primary>
      </indexterm>
      <indexterm>
        <primary>Section, FILE</primary>
      </indexterm>
      <para>
In a CIS COBOL program the file description entry (FD) represents the
highest level or organization in the File Section. The File Section header
is followed by a file description entry consisting of a level indicator
(FD), a file-name and a series of independent clauses. The FD clauses
specify the size of the logical and physical records, the presence or
absence of label records, the value of implementor-defined label items, and
the names of the data records which comprise the file. The entry itself is
terminated by a period.
</para>
    </section>
    <section>
      <title>RECORD DESCRIPTION STRUCTURE</title>
      <indexterm>
        <primary>Record Description Structure</primary>
      </indexterm>
      <indexterm>
        <primary>Structure, Record Description</primary>
      </indexterm>
      <para>
A record description consists of a set of data description entries which
describe the characteristics of a particular record. Each data description
entry consists of a level-number followed by a data-name if required,
followed by a series of independent clauses as required. A record
description has a hierarchical structure and therefore the clauses used with
an entry may vary considerably, depending upon whether or not it is followed
by subordinate entries. The structure of a record description is defined in
CONCEPTS OF LEVELS in Chapter 2 while the elements allowed in a record
description are shown in <xref linkend="c03.skeleton"/> in Chapter 3.
</para>
    </section>
    <section>
      <title>THE FILE DESCRIPTION-COMPLETE ENTRY SKELETON</title>
      <indexterm>
        <primary>File Description Entry</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The file description furnishes information concerning the physical
structure, identification, and record names pertaining to a given file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <command>FD</command>
          <arg>file-name</arg>
          <arg choice="opt">
            <arg>; BLOCK CONTAINS integer-2</arg>
            <group choice="req">
              <arg>RECORDS</arg>
              <arg>CHARACTERS</arg>
            </group>
          </arg>
          <sbr/>
          <arg choice="opt">
            <arg>; RECORD CONTAINS</arg>
            <arg choice="opt">integer-3 TO</arg>
            <arg>integer-4 CHARACTERS</arg>
          </arg>
          <sbr/>
          <arg choice="opt">
            <arg>; LABEL</arg>
            <group choice="req">
              <arg>RECORD IS</arg>
              <arg>RECORDS ARE</arg>
            </group>
            <group choice="req">
              <arg>STANDARD</arg>
              <arg>OMITTED</arg>
            </group>
          </arg>
          <sbr/>
          <arg choice="opt">
            <arg>; VALUE OF implementor-name-1 IS literal-1</arg>
            <arg choice="opt" rep="repeat">, implementor-name-2 IS literal-2</arg>
          </arg>
          <arg choice="opt">
            <arg>; DATA</arg>
            <group choice="req">
              <arg>RECORD IS</arg>
              <arg>RECORDS ARE</arg>
            </group>
            <arg>data-name-3</arg>
            <arg choice="opt">, data-name-4</arg>
          </arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
The level indicator FD identifies the beginning of a file description
and must precede the file-name.
</para>
          </listitem>
          <listitem>
            <para>
The clauses which follow the name of the file are
cases, and their order of appearance is immaterial.
</para>
          </listitem>
          <listitem>
            <para>
One or more record description entries must follow the file description entry.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE BLOCK CONTAINS CLAUSE</title>
      <indexterm>
        <primary>BLOCK CONTAINS Clause</primary>
      </indexterm>
      <indexterm>
        <primary>Clause, BLOCK CONTAINS</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The BLOCK CONTAINS clause specifies the size of a physical record.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <command>BLOCK CONTAINS</command>
          <arg>integer-2</arg>
          <group choice="req">
            <arg>RECORDS</arg>
            <arg>CHARACTERS</arg>
          </group>
        </cmdsynopsis>
      </section>
      <section>
        <title>General Rules</title>
        <para>
</para>
      </section>
    </section>
    <section>
      <title>THE DATA RECORDS CLAUSE</title>
      <indexterm>
        <primary>DATA RECORDS Clause</primary>
      </indexterm>
      <indexterm>
        <primary>Clause, DATA RECORDS</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The DATA RECORDS clause serves only as documentation for the names of
data records with their associated file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>DATA</arg>
          <group choice="req">
            <arg>RECORD IS</arg>
            <arg>RECORDS ARE</arg>
          </group>
          <arg>data-name-1</arg>
          <arg choice="opt">, data-name-2</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rule</title>
        <para>
Data-name-1 and data-name-2 are the names of data records and should
have 01 level-number record descriptions, with the same names,
associated with them.
</para>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The presence of more than one data-name indicates that the file
contains more than one type of data record. These records may be of
differing sizes, different formats, etc. The order in which they are
listed is not significant.
</para>
          </listitem>
          <listitem>
            <para>
Conceptually, all data records within a file share the same area. This
is in no way altered by the presence of more than one type of data
record within the file.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE LABEL RECORDS CLAUSE</title>
      <indexterm>
        <primary>LABEL RECORDS Clause</primary>
      </indexterm>
      <indexterm>
        <primary>Clause, LABEL RECORDS</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
       The LABEL RECORDS clause specifies whether labels are present.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>LABEL</arg>
          <group choice="req">
            <arg>RECORD IS</arg>
            <arg>RECORDS ARE</arg>
          </group>
          <group choice="req">
            <arg>STANDARD</arg>
            <arg>OMITTED</arg>
          </group>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rule</title>
        <para>
This clause is required in every file description entry, <phrase role="extension">when the ANSI switch is set.</phrase>
</para>
      </section>
      <section>
        <title>General Rule</title>
        <para>
          <phrase role="extension">This clause is used for documentation purposes only.</phrase>
        </para>
      </section>
    </section>
    <section>
      <title>THE RECORD CONTAINS CLAUSE</title>
      <indexterm>
        <primary>RECORD CONTAINS Clause</primary>
      </indexterm>
      <indexterm>
        <primary>Clause, RECORD CONTAINS</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
   The RECORD CONTAINS clause specifies the size of data records.
</para>
      </section>
      <section>
        <title>Format</title>
        <cmdsynopsis>
          <arg>RECORD CONTAINS</arg>
          <arg choice="opt">integer-1 TO</arg>
          <arg>integer-2 CHARACTERS</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>General Rule</title>
        <para>
     The size of each data record is completely defined within the record
     description entry, therefore this clause is never required.
</para>
      </section>
    </section>
    <section>
      <title>THE VALUE OF CLAUSE</title>
      <indexterm>
        <primary>VALUE OF Clause</primary>
      </indexterm>
      <indexterm>
        <primary>Clause, VALUE OF</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
     The VALUE of clause specialises the description of an item in the label
records associated with a file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>VALUE OF</arg>
          <arg>data-name-1 IS literal-1</arg>
          <arg choice="opt" rep="repeat">, data-name-2 IS literal-2</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
  Data-name-1, data-name-2, etc, should be qualified when necessary, but
     cannot be subscripted or indexed, nor can they be items described with
     the USAGE IS  INDEX clause
</para>
          </listitem>
          <listitem>
            <para>
  Data-name-1, data-name-2 etc, must be in the Working-Storage Section
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
              <phrase role="extension">This clause is used for documentation purposes only.</phrase>
            </para>
          </listitem>
          <listitem>
            <para>
A figurative constant may be substituted in the format above wherever a literal is specified.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
  </section>
  <section>
    <title>PROCEDURE DIVISION IN THE RELATIVE I-O MODULE</title>
    <indexterm>
      <primary>Procedure Division in Relative</primary>
    </indexterm>
    <indexterm>
      <primary>Relative I-O Module, Procedure Division</primary>
    </indexterm>
    <section>
      <title>THE CLOSE STATEMENT</title>
      <indexterm>
        <primary>CLOSE Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, CLOSE</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The CLOSE statement terminates the procession of files.
<phrase role="extension">The LOCK is for documentation purposes only.</phrase>
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>CLOSE</arg>
          <arg>file-name-1</arg>
          <arg choice="opt">WITH LOCK</arg>
          <arg choice="opt" rep="repeat">, file-name-2 <arg choice="opt">WITH LOCK</arg></arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rule</title>
        <para>
The files referenced in the CLOSE statement need not all have the same
organization or access.
</para>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
A CLOSE statement may only be executed for a file in an open mode.
</para>
          </listitem>
          <listitem>
            <para>
The action taken if a file is in the open mode when a STOP RUN
statement is executed is to close the file. The action taken for a
file that has been opened in a called program and not closed in that
program prior to the execution of a CANCEL statement for the program is
to close the file.
</para>
          </listitem>
          <listitem>
            <para>
If a CLOSE statement has been executed for a file, no other statement
can be executed that references that file, either explicitly or
implicitly, unless an intervening OPEN statement for that file is executed.
</para>
          </listitem>
          <listitem>
            <para>
Following the successful execution of a CLOSE statement, the record
area associated with file-name is no longer available. The
unsuccessful execution of such a CLOSE statement leaves the
availability of the record area undefined.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE DELETE STATEMENT</title>
      <indexterm>
        <primary>DELETE Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, DELETE</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
      The DELETE statement logically removes a record from a mass storage file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>DELETE file-name RECORD</arg>
          <arg choice="opt">;INVALID KEY imperative-statement</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
The INVALID KEY phrase must not be specified for a DELETE statement
which references a file which is in sequential access mode.
</para>
          </listitem>
          <listitem>
            <para>
The INVALID KEY phrase must be specified for a DELETE statement which
references a file which is not in sequential access mode and for which
an applicable USE procedure is not specified
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The associated file must be open in the I-O mode at the time of the
execution of this statement. (See THE OPEN STATEMENT later in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
For files in the sequential access mode, the last input-output
statement executed for file-name prior to the execution of the DELETE
statement must have been a successfully executed READ statement. The
Operating System logically removes from the file the record that was
accessed by that READ statement.
</para>
          </listitem>
          <listitem>
            <para>
For a file in random or dynamic access mode, the Operating System
logically removes from the file that record identified by the contents
of the RELATIVE KEY data item associated with file-name. If the file
does not contain the record specified by the key, an INVALID key
condition exists. (See <xref linkend="sec6.inv.key"/> in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
After the successful execution of a DELETE statement, the identified
record has been logically removed from the file and can no longer be accessed.
</para>
          </listitem>
          <listitem>
            <para>
The execution of a DELETE statement does not affect the contents of the
record area associated with file-name.
</para>
          </listitem>
          <listitem>
            <para>
The current record pointer is not affected by the execution of a DELETE statement.
</para>
          </listitem>
          <listitem>
            <para>
The execution of the DELETE statement causes the value of the specified
FILE STATUS data item, if any, associated with the file-name to be updated.
See <xref linkend="sec6.i.o"/> in this chapter.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE OPEN STATEMENT</title>
      <indexterm>
        <primary>OPEN Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, OPEN</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The OPEN statement initiates the processing of files. It also performs
checking and/or writing of labels and other input-output operations.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg choice="plain">OPEN</arg>
          <group choice="req" rep="repeat">
            <arg choice="plain">
              <arg choice="plain">INPUT <replaceable>file-name-1</replaceable></arg>
              <arg choice="opt" rep="repeat">, <replaceable>file-name-2</replaceable></arg>
            </arg>
            <arg choice="plain">
              <arg choice="plain">OUTPUT <replaceable>file-name-3</replaceable></arg>
              <arg choice="opt" rep="repeat">, <replaceable>file-name-4</replaceable></arg>
            </arg>
            <arg choice="plain">
              <arg choice="plain">I-O <replaceable>file-name-5</replaceable></arg>
              <arg choice="opt" rep="repeat">, <replaceable>file-name-6</replaceable></arg>
            </arg>
          </group>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rule</title>
        <para>
The files referenced in the OPEN statement need not all have the same
organization or access.
</para>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The successful execution of an OPEN statement determines the
availability of the file and results in the file being in an open mode.
</para>
          </listitem>
          <listitem>
            <para>
The successful execution of the OPEN statement makes the associated
record area available to the program.
</para>
          </listitem>
          <listitem>
            <para>
Prior to the successful execution of an OPEN statement for a given
file, no statement can be executed that references that file, either
explicitly or implicitly.
</para>
          </listitem>
          <listitem>
            <para>
An OPEN statement must be successfully executed prior to the execution
of any of the permissible input-output statements. In Table 6-1, 'X'
at an intersection indicates that the specified statement, used in the
access mode given for that row, may be used with the relative file
organization and the open mode given at the top of the column.
</para>
            <table>
              <title>Permissible Combinations of Statements and Open Modes for Relative I/O</title>
              <tgroup cols="5">
                <colspec colwidth="1.0in" colname="c1"/>
                <colspec colwidth="1.0in" colname="c2"/>
                <colspec colwidth="1.0in" colname="c3"/>
                <colspec colwidth="1.0in" colname="c4"/>
                <colspec colwidth="1.0in" colname="c5"/>
                <thead>
                  <row>
                    <entry morerows="1">File Access Mode</entry>
                    <entry morerows="1">Statement</entry>
                    <entry namest="c3" nameend="c5">Open Mode</entry>
                  </row>
                  <row>
                    <entry>Input</entry>
                    <entry>Output</entry>
                    <entry>Input-Output</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry morerows="4">Sequential</entry>
                    <entry>READ</entry>
                    <entry>X</entry>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>WRITE</entry>
                    <entry/>
                    <entry>X</entry>
                    <entry/>
                  </row>
                  <row>
                    <entry>REWRITE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>START</entry>
                    <entry>X</entry>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>DELETE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry morerows="4">Random</entry>
                    <entry>READ</entry>
                    <entry>X</entry>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>WRITE</entry>
                    <entry/>
                    <entry>X</entry>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>REWRITE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>START</entry>
                    <entry/>
                    <entry/>
                    <entry/>
                  </row>
                  <row>
                    <entry>DELETE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry morerows="4">Dynamic</entry>
                    <entry>READ</entry>
                    <entry>X</entry>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>WRITE</entry>
                    <entry/>
                    <entry>X</entry>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>REWRITE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>START</entry>
                    <entry>X</entry>
                    <entry/>
                    <entry>X</entry>
                  </row>
                  <row>
                    <entry>DELETE</entry>
                    <entry/>
                    <entry/>
                    <entry>X</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </listitem>
          <listitem>
            <para>
A file may be opened with the INPUT, OUTPUT, AND I-O phrases in the
same program. Following the initial execution of an OPEN statement for
a file, each subsequent execution for that sane file must be preceded
by the execution of a CLOSE statement, for that file.
</para>
          </listitem>
          <listitem>
            <para>
Execution of the OPEN statement does not obtain or release the first
data record.
</para>
          </listitem>
          <listitem>
            <para>
The file description entry for file-name-1, file-name-2, file-name-5 or
file-name-6 must be equivalent to that used when this file was created.
</para>
          </listitem>
          <listitem>
            <para>
For files being opened with the INPUT or I-O phrase, the OPEN statement
sets the current record pointer to the first record
currently existing within the file. If no records exist in the file,
the current record pointer is set such that the next executed Format 1
READ statement for the file will result in an AT END condition. If the
file does not exist, INPUT will cause an error status.
</para>
          </listitem>
          <listitem>
            <para>
The I-O phrase permits the opening of a file for both input and output
operations. <phrase role="extension">If the file does not exist, it will be created. In
sequential access mode it will then be used for input; any attempt to
WRITE to it will cause an error.</phrase>
</para>
          </listitem>
          <listitem>
            <para>
Upon successful execution of an OPEN statement with the OUTPUT phrase
specified, a file is created. At the time the associated file 
contains no data. <phrase role="extension">If a file of the same number exists it will
be deleted. If write protected, an error status occurs.</phrase>
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE READ STATEMENT</title>
      <indexterm>
        <primary>READ Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, READ</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
For sequential access, the READ statement makes available the next logical
record from a file. For random access, the READ statement makes available a
specified record from a disk file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <para>
Format 1
</para>
        <cmdsynopsis>
          <command>READ</command>
          <arg>file-name</arg>
          <arg choice="opt">NEXT</arg>
          <arg>RECORD</arg>
          <arg choice="opt">INTO identifier</arg>
          <arg choice="opt">; AT END imperative-statement</arg>
        </cmdsynopsis>
        <para>
Format 2
</para>
        <cmdsynopsis>
          <command>READ</command>
          <arg>file-name</arg>
          <arg>RECORD</arg>
          <arg choice="opt">INTO identifier</arg>
          <arg choice="opt">;INVALID KEY imperative-statement</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
The INTO phrase must not be used when the input file contains logical
records of various sizes as indicated by their record descriptions. The
storage area associated with identifier and the record area associated
with file-name must not be the same storage area.
</para>
          </listitem>
          <listitem>
            <para>
Format must be used (without the NEXT phrase) for all files in
sequential access mode.
</para>
          </listitem>
          <listitem>
            <para>
The NEXT phrase must be specified for files in dynamic access mode,
when records are to be retrieved sequentially.
</para>
          </listitem>
          <listitem>
            <para>
Format 2 is used for files in random access mode or for files in
dynamic access mode when records are to be retrieved randomly.
</para>
          </listitem>
          <listitem>
            <para>
The INVALID KEY phrase or the AT END phrase must be specified if no
applicable USE procedure is specified for file-name.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The associated files must be open in the INPUT or I-O mode at the time
this statement is executed. See THE OPEN STATEMENT in this Chapter.
</para>
          </listitem>
          <listitem>
            <para>
The record to be made available by a Format 1 READ statement is
determined as follows:
</para>
            <orderedlist>
              <listitem>
                <para>
The record, pointed to by the current record pointer, is made
available provided that the current record pointer was positioned
by the START or OPEN statement and the record is still accessible
through the path indicated by the current record pointer; if the
record is no longer accessible, which may have been caused by the
deletion of the record, the current record pointer is updated to
point to the next existing record in the file and that record is
then made available.
</para>
              </listitem>
              <listitem>
                <para>
If the current record pointer was positioned by the execution of a
previous READ statement, the current record pointer is updated to
point to the next existing record in the file and then that record
is made available.
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
The execution of the READ statement causes the value of the FILE STATUS
data item, if any, associated with filename to be updated.
(See <xref linkend="sec6.i.o"/> in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
Regardless of the method used to overlap access time with processing
time, the concept of the READ statement is unchanged in that a record
is available to the object program prior to the execution of any
statement following the READ statement.
</para>
          </listitem>
          <listitem>
            <para>
When the logical records of a file are described with more than one
record description, these records automatically share the same storage
area; this is equivalent to an implicit redefinition of the area. The
contents of any data items which lie beyond the range of the current
data record are undefined at the completion of the execution of the
READ statement.
</para>
          </listitem>
          <listitem>
            <para>
If the I-O phrase is specified, the record being read is moved from
the record area to the area specified by identifier according to the
rules specified for the MOVE statement without the CORRESPONDING
phrase. The implied MOVE does not occur if the execution of the READ
statement was unsuccessful. Any subscripting or indexing associated
with identifier is evaluated after the record has been read and
immediately before it is moved to the data item.
</para>
          </listitem>
          <listitem>
            <para>
When the INTO phrase is used, the record being read is available in
both the input record area and the data area associated with identifier.
</para>
          </listitem>
          <listitem>
            <para>
If, at the time of execution of a Format 1 READ statement, the position
of current record pointer for that file is undefined, the execution of
that READ statement is unsuccessful.
</para>
          </listitem>
          <listitem>
            <para>
If, at the time of the execution of a Format 1 READ statement, no next
logical record exists in the file, the AT END condition occurs, and the
execution of the READ statement is considered unsuccessful.
(See <xref linkend="sec6.i.o"/> in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
When the AT END condition is recognized the following actions are taken
in the specified order:
</para>
            <orderedlist>
              <listitem>
                <para>
           A value is placed into the FILE STATUS data item, if specified for
             this file, to indicate an AT END condition.
             (See <xref linkend="sec6.i.o"/> in this Chapter)
</para>
              </listitem>
              <listitem>
                <para>
          If the AT END phrase is specified in the statement causing the
             condition, control is transferred to the AT END
             imperative-statement.   Any USE procedure specified for this file
             is not executed.
</para>
              </listitem>
              <listitem>
                <para>
       If the AT END phrase is not specified, then a USE procedure must
         be specified, either explicitly or implicitly, for this file, and
         that procedure is executed.
         When the AT END condition occurs, execution of the input-output
         statement which caused the condition is unsuccessful.
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
Following the unsuccessful execution of any READ statement, the
contents of the associated record area and the position of the current
record pointer are undefined.
</para>
          </listitem>
          <listitem>
            <para>
When the AT END condition has been recognised, a Format 1 READ
statement for that file must not be executed without first executing
one of the following:
</para>
            <orderedlist>
              <listitem>
                <para>
A successful CLOSE statement followed by the execution of a
successful OPEN statement for that file.
</para>
              </listitem>
              <listitem>
                <para>
       A successful START statement for that file.
</para>
              </listitem>
              <listitem>
                <para>
A successful Format 2 READ statement for that file.
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
For a file for which dynamic access mode is specified, a Format 1 READ
statement with the NEXT phrase specified causes the next logical record
to be retrieved from the file as described in general rule 2.
</para>
          </listitem>
          <listitem>
            <para>
If the RELATIVE KEY phrase is specified, the execution of a Format 1
READ statement updates the contents of the RELATIVE KEY data item such
that it contains the relative record number of the record made available.
</para>
          </listitem>
          <listitem>
            <para>
The execution of a Format 2 READ statement sets the current record
pointer to, and makes available, the record whose relative record
number is contained in the data item named in the RELATIVE KEY phrase
for the file. If the file does not contain such a record,
the INVALID KEY condition exists and execution of the READ statement is
unsuccessful. (See <xref linkend="sec6.inv.key"/> in this Chapter).
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE REWRITE STATEMENT</title>
      <indexterm>
        <primary>REWRITE Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, REWRITE</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The REWRITE statement logically replaces a record existing in a disk file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <command>REWRITE</command>
          <arg>record-name</arg>
          <arg choice="opt">FROM identifier</arg>
          <arg choice="opt">; INVALID KEY imperative-statement</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
Record-name and identifier must not refer to the same storage area.
</para>
          </listitem>
          <listitem>
            <para>
Record-name is the name of a logical record in the File Section of the Data Division.
</para>
          </listitem>
          <listitem>
            <indexterm>
              <primary>Conditions, INVALID KEY</primary>
            </indexterm>
            <indexterm>
              <primary>INVALID KEY Condition</primary>
            </indexterm>
            <para>
The INVALID KEY phrase must be specified in the REWRITE statement for
files in the random or dynamic access mode for which an appropriate USE
procedure is not specified.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
The file associated with record-name must be open in the I-O mode at
the time of execution of this statement.
(See THE OPEN STATEMENT in this Chapter)
</para>
          </listitem>
          <listitem>
            <para>
For files in the sequential access mode, the last input-output
statement executed for the associated file prior to the execution of
the REWRITE statement must have been a successfully executed READ
statement. The Operating System logically replaces the record that was
accessed by the READ statement.
</para>
          </listitem>
          <listitem>
            <para>
The number of character positions in the record referenced by
record-name must be equal to the number of character positions in the
record being replaced.
</para>
          </listitem>
          <listitem>
            <para>
The logical record released by a successful execution of the REWRITE
statement is no longer available in the record area.
</para>
          </listitem>
          <listitem>
            <para>
 The execution of a REWRITE statement with the FROM phrase is equivalent
     to the execution of:
</para>
            <programlisting>
          MOVE identifier TO record-name
</programlisting>
            <para>
     followed by the execution of the same REWRITE statement without the
     FROM phrase. The contents of the record area prior to the execution of
     the implicit MOVE statement have no effect on the execution of the
    REWRITE statement.
</para>
          </listitem>
          <listitem>
            <para>
The current record pointer is not affected by the execution of a
   REWRITE statement.
</para>
          </listitem>
          <listitem>
            <para>
The execution of the REWRITE statement causes the value of the FILE
STATUS data item, if any, associated with the file to be updated.
(See <xref linkend="sec6.i.o"/> in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
For a file accessed in either random or dynamic access mode, the
Operating System logically replaces the record specified by the
contents of the RELATIVE KEY data item associated with the file.
If the file does not contain the record specified by the key, the INVALID
KEY condition exists. (See <xref linkend="sec6.inv.key"/> in this Chapter).
The updating operation does not take place and the data in the record
area is unaffected.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE START STATEMENT</title>
      <indexterm>
        <primary>START Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, START</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
  The START statement provides a basis for logical positioning within a
  relative file, for subsequent sequential retrieval of records.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <arg>START file-name</arg>
          <arg choice="opt">
            <arg>KEY</arg>
            <group>
              <arg>IS EQUAL TO</arg>
              <arg>IS =</arg>
              <arg>IS GREATER THAN</arg>
              <arg>IS &gt;</arg>
              <arg>IS NOT LESS THAN</arg>
              <arg>IS NOT &lt;</arg>
            </group>
            <arg>data-name</arg>
            <sbr/>
            <arg choice="opt">;INVALID KEY imperative-statement</arg>
          </arg>
        </cmdsynopsis>
        <para>
NOTE:      The required relational characters '&gt;', and '&lt;' and '='
  are not underlined to avoid confusion with other symbols
  such as '&#x2265;' (greater than or equal to).
</para>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
File-name must be the name of a file with sequential or dynamic access.
</para>
          </listitem>
          <listitem>
            <para>
Data-name may be qualified.
</para>
          </listitem>
          <listitem>
            <para>
The INVALID KEY phrase must be specified if no applicable USE procedure
        is specified for file-name.
</para>
          </listitem>
          <listitem>
            <para>
Data-name, if specified, must be the data item specified in the
        RELATIVE KEY phrase of the associated file control entry.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
File-name must be open in the INPUT or I-O mode at the time that the
        START statement is executed. (See THE OPEN STATEMENT in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
If the KEY phrase is not specified the relational operator 'IS EQUAL TO' is implied.
</para>
          </listitem>
          <listitem>
            <para>
The type of comparison specified by the relational operator in the KEY
        phrase occurs between a key associated with a record in the file
        referenced by file-name and a data item as specified in general Rule 5.
</para>
            <orderedlist>
              <listitem>
                <para>
            The current record pointer is positioned to the first logical
              record currently existing in the file whose key satisfies the comparison.
</para>
              </listitem>
              <listitem>
                <para>
     If the comparison is not sattified by any record in the file, an
        INVALID KEY condition exists, the execution of the START statement
        is unsuccessful, and the position of the current record pointer is
        undefined. (See <xref linkend="sec6.inv.key"/> in this Chapter).
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
The execution of the START statement causes the value of the FILE
   STATUS data item, if any, associated with file-name to be updated.
   (See <xref linkend="sec6.i.o"/> in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
The comparison described in general rule 3 uses the data item
   referenced by the RELATIVE KEY clause associated with file-name.

</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE USE STATEMENT</title>
      <indexterm>
        <primary>USE Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, USE</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The USE statement specifies procedures for input-output error handling that
are in addition to the standard procedures provided by the input-output control system.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <command>USE  AFTER STANDARD</command>
          <group choice="req">
            <arg>EXCEPTION</arg>
            <arg>ERROR</arg>
          </group>
          <arg>PROCEDURE ON</arg>
          <group choice="req">
            <arg>file-name-1</arg>
            <arg>INPUT</arg>
            <arg>OUTPUT</arg>
            <arg>I-O</arg>
          </group>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
A USE statement, when present, must immediately follow a section header
            in the declaratives section and must be followed by a period followed
              by a space. The remainder of the section must consist of zero, one or
              more procedural paragraphs that define the procedures to be used.
</para>
          </listitem>
          <listitem>
            <para>
The USE statement itself is never executed; it merely defines the
              conditions calling for the execution of the USE procedures.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
If the INVALID KEY or AT END phrases have not been specified in the
              input-output statement, the designated procedures are executed by the
              input-output system after completing the standard input-output error
              routine, or upon recognition of the INVALID KEY or AT END conditions.
</para>
          </listitem>
          <listitem>
            <para>
After execution of a USE procedure, control is returned to the invoking routine.
</para>
          </listitem>
          <listitem>
            <para>
Within a USE procedure, there must not be any reference to any
              nondeclarative procedures. Conversely, in the nondeclarative portion
              there must be no reference to procedure-names in the declarative
              portion, except that PERFORM statements may refer to a USE statement or
              to the procedures associated with such a USE statement.
</para>
          </listitem>
          <listitem>
            <para>
Within a USE procedure, there must not be the execution of any
              statement that would cause the execution of a USE procedure that had
              previously been invoked and had not yet returned control to the
              invoking routine.
</para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>THE WRITE STATEMENT</title>
      <indexterm>
        <primary>WRITE Statement</primary>
      </indexterm>
      <indexterm>
        <primary>Statement, WRITE</primary>
      </indexterm>
      <section>
        <title>Function</title>
        <para>
The WRITE statement releases a logical record for an output or input-output file.
</para>
      </section>
      <section>
        <title>General Format</title>
        <cmdsynopsis>
          <command>WRITE</command>
          <arg>record-name</arg>
          <arg choice="opt">FROM identifier</arg>
          <arg choice="opt">; INVALID KEY imperative-statement</arg>
        </cmdsynopsis>
      </section>
      <section>
        <title>Syntax Rules</title>
        <orderedlist>
          <listitem>
            <para>
   Record-name and identifier must not reference the same storage area.
</para>
          </listitem>
          <listitem>
            <para>
   The record-name is the name of a logical record in the File Section of
      the Data Division.
</para>
          </listitem>
          <listitem>
            <para>
   The INVALID KEY phrase must be specified if an applicable USE procedure
      is not specified for the associated file.
</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>General Rules</title>
        <orderedlist>
          <listitem>
            <para>
   The associated file must be open in the OUTPUT or I-O mode at the time
      of the execution of this statement. (See THE OPEN STATEMENT Chapter).
</para>
          </listitem>
          <listitem>
            <para>
   The logical record released by the execution of the WRITE statement is
      no longer available in the record area unless the execution of the
      WRITE statement is unsuccessful due to an INVALID KEY condition.
</para>
          </listitem>
          <listitem>
            <para>
The results of the execution of. the WRITE statement with the FROM
      phrase is equivalent to the execution of
</para>
            <orderedlist>
              <listitem>
                <para>
The statement:
</para>
                <programlisting>
           MOVE identifier TO record-name
</programlisting>
                <para>
           according to the rules specified for the MOVE statement, followed by:
</para>
              </listitem>
              <listitem>
                <para>
The same WRITE statement without the FROM phrase.
</para>
                <para>
           The contents of the record area prior to the execution of the
            implicit MOVE statement have no effect on the execution of this
           WRITE statement.
</para>
                <para>
           After execution of the WRITE statement is complete, the
            information in the area referenced by identifier is available,
           even though the information in the area referenced by record-name
           may not be. (See general rule 2 above).
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
   The current record pointer is unaffected by the execution of a WRITE
      statement.
</para>
          </listitem>
          <listitem>
            <para>
  The execution of the WRITE statement causes the value of the FILE
     STATUS data item, if any, associated with the file to be updated.
     (See <xref linkend="sec6.i.o"/> in this Chapter).
</para>
          </listitem>
          <listitem>
            <para>
  The maximum record size for a file ts established at the time the file
     is created and must not subsequently be changed.
</para>
          </listitem>
          <listitem>
            <para>
  The number of character positions on a mass storage device required to
     store a logical record in a file may or may not be equal to the number
     of character positions defined by the logical description of that
     record in the program.
</para>
          </listitem>
          <listitem>
            <para>
 The execution of the WRITE statement releases a logical record to the
     operating system.
</para>
          </listitem>
          <listitem>
            <para>
  When a file is opened in the output mode, records may be placed into
     the file by one of the following:
</para>
            <orderedlist>
              <listitem>
                <para>
If the access mode is sequential, the WRITE statement will cause a
record to be released to the Operating System. The first record
will have a relative record number of one and subsequent records
released will have relative record numbers of 2, 3, 4.  If the
RELATIVE KEY data item has been specified in the file control
entry for the associated file, the relative record number of the
record just released will be placed into the RELATIVE KEY data
item by the Operating System during execution of the WRITE statement.
</para>
              </listitem>
              <listitem>
                <para>
If the access mode is random or dynamic, prior to the execution of
the WRITE statement the value of the RELATIVE KEY data item must
be initialised in the program with the relative record number of
be associated with the record in the record area. That record is
then released to the Operating System by execution of the WRITE statement.
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
When a file is opened in the I-O mode and the access mode is random or
dynamic, records are to be inserted in the associated file. The value
of the RELATIVE KEY data item must be initialised by the program with
the relative record number to be associated with the record in the
record area. Execution of a WRITE statement then causes the contents
of the record area to be released to the Operating System.
</para>
          </listitem>
          <listitem>
            <para>
The INVALID KEY condition exists under the following circumstances:
</para>
            <orderedlist>
              <listitem>
                <para>
When the access mode is random or dynamic, and the RELATIVE KEY
data item specifies a record which already exists in the file, or
</para>
              </listitem>
              <listitem>
                <para>
When an attempt is made to write beyond the externally defined
boundaries of the file.
</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
When the INVALID KEY condition is recognised, the execution of the
WRITE statement is unsuccessful, the contents of the record area are
unaffected, and the FILE STATUS data item, if any, of the, associated
file is set to a value indicating the cause of the condition.
Execution of the program proceeds according to the rules stated in
<xref linkend="sec6.inv.key"/> in this Chapter (see also <xref linkend="sec6.i.o"/> in this Chapter).
  </para>
          </listitem>
        </orderedlist>
      </section>
    </section>
  </section>
</chapter>
